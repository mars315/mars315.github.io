<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Eralng系列文章</title>
    <url>/2017/12/24/Erlang/</url>
    <content><![CDATA[<h1 id="eralng系列文章"><a class="markdownIt-Anchor" href="#eralng系列文章"></a> Eralng系列文章</h1>
<table>
<thead>
<tr>
<th>Author</th>
<th>snail</th>
</tr>
</thead>
<tbody>
<tr>
<td>E-mail</td>
<td><a href="mailto:254262243@qq.com">254262243@qq.com</a></td>
</tr>
</tbody>
</table>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>从业以来一直用C++，面对各种问题特别管理一个C<ins>团队时在服务器健壮性、效率等等方面做的工作又多又繁琐，人工以及各种工具齐上阵，深感心力交瘁。后来机缘巧合接触到Erlang，初识Erlang感觉很神奇无不为其各种特性所折服。但随后实际项目的应用过程中还是出现了各种问题，虽然相对于C</ins>难度有所降低，但是对于C++有多年的经验，在处理各种问题上都有相应的经验；但是Erlang运行于Erlang VM上还有各种封装，如果不了解一些内部细节在处理各种问题时真是摸不着头脑。我在工作中别人问的最多的问题或者我当初在写代码时最想知道的问题大概有如下几个：</p>
<blockquote>
<p>为什么一个进程的消息队列堆积会导致真个VM效率下降?<br>
变量在什么地方分配在堆？栈？还是什么地方？<br>
对于变量不可以变每次修改是否会重新分配?在哪里分配？效率怎么样?<br>
进程什么时候GC？怎样做GC？GC堆进程影响？<br>
进程内存(erlang:memory/1) 由哪些部分组成？<br>
怎样调优VM以及自己逻辑的代码？<br>
…</p>
</blockquote>
<p>上面的这些问题如果不了Erlang的调度器、VM、内存管理策略、GC、以及进程的实现等等很难找准方向，在<a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考很多资料</a>，写了后面<a href="#%E6%96%87%E7%AB%A0">四个文档</a>用来对我看过的资料做个总结</p>
<h2 id="文章"><a class="markdownIt-Anchor" href="#文章"></a> 文章</h2>
<ul>
<li>
<a href="/2017/12/24/ErlangScheduler/" title="[Eralng VM Scheduler]">[Eralng VM Scheduler]</a>  
</li>
<li>
<a href="/2017/12/24/ErlangMemoryAllocator/" title="[Eralng Memory Allocator]">[Eralng Memory Allocator]</a>
</li>
<li>
<a href="/2017/12/24/ErlangGarbageCollection/" title="[Eralng Garbage Collection]">[Eralng Garbage Collection]</a>
</li>
<li>
<a href="/2017/12/24/ErlangProcess/" title="[Eralng Process]">[Eralng Process]</a>
</li>
</ul>
<h2 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2>
<ul>
<li>
<a href="/2017/12/24/ErlangNodeConnect/" title="[Eralng 节点互联]">[Eralng 节点互联]</a>
</li>
<li>
<a href="/2017/12/24/ReadingNotes/" title="[Eralng 读书笔记]">[Eralng 读书笔记]</a>
</li>
<li>
<a href="/2017/12/24/Erlang2Elixir/" title="[Eralng to Elixir]">[Eralng to Elixir]</a>
</li>
</ul>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<blockquote>
<p><a href="http://blog.yufeng.info/">霸爷的博客</a><br>
<a href="https://happi.github.io/theBeamBook">The Beam Book</a><br>
高伸缩性系统：Erlang/OTP大型分布式容错设计<br>
<a href="https://github.com/ferd">Fred Hebert</a><br>
<a href="https://github.com/garazdawi">Lukas Larsson</a><br>
<a href="https://www.erlang-solutions.com/">Erlang solution</a><br>
<a href="https://github.com/erlang/otp/blob/master/erts/emulator/internal_doc/">Erlang Otp Internal Doc</a><br>
<a href="http://www.erlang-factory.com/">Erlang Factory</a><br>
<a href="http://bit.ly/2FtbBAL">Code BEAM SF</a><br>
<a href="https://codesync.global/">Code Sync</a><br>
其他的博客、文档 等等</p>
</blockquote>
]]></content>
      <categories>
        <category>Erlang</category>
      </categories>
      <tags>
        <tag>Erlang</tag>
      </tags>
  </entry>
  <entry>
    <title>Erlang to Elixir</title>
    <url>/2017/12/24/Erlang2Elixir/</url>
    <content><![CDATA[<h1 id="erlang-to-elixir"><a class="markdownIt-Anchor" href="#erlang-to-elixir"></a> Erlang to Elixir</h1>
<h2 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h2>
<ul>
<li>原子有冒号 <code>:ok</code> 或者 <code>Atom</code></li>
<li>变量<code>ok </code></li>
<li><code>"hello"</code> 是<code>bianry</code> ，<code>'hello'</code> 是<code>list</code></li>
</ul>
<blockquote>
<p>❗ 所有定义比如<code>def</code> <code>defp</code> 等等以<code>p</code>结束的都是私有的</p>
</blockquote>
<ul>
<li>对应 Erlang的宏定义：<code>@is_running false</code></li>
<li>record 定义 <code>defrecordp</code>  <code>defrecord</code></li>
<li>结构体体是字典的特殊形式，它们的键是预定义的，一般都有默认值。结构体必须定义在某个模块内部，因此也必须通过模块的命名空间来访问。定义一个结构体，我们使用 <code>defstruct</code> 关键字，后面跟着关键字列表和默认值 (通俗的将就是键在编译时就确定了的map)</li>
</ul>
<figure class="highlight elixir"><table><tbody><tr><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">defmodule</span>  <span class="title">Example.User</span></span>  <span class="keyword">do</span>  </span><br><span class="line">    <span class="keyword">defstruct</span>  <span class="symbol">name:</span>  <span class="string">"Sean"</span>,  <span class="symbol">roles:</span>  []  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">iex&gt;  %<span class="title class_">Example</span>.<span class="title class_">User</span>{}</span><br><span class="line">iex&gt;  steve  =  <span class="comment">#Example.User&lt;name: "Steve", roles: []&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<span id="more"></span>
<ul>
<li>模块定义 <code>defmodule</code></li>
<li>elixir里面的<code>宏</code>(<code>defmacro</code>)跟erlang里的<code>宏</code>完全不同,涉及到元编程</li>
<li>抛异常不用<code>throw</code> 用<code>raise</code></li>
<li>elixir 一切定义都必须包含在 模块里<code>defmoudlue XXX do  ... end</code></li>
<li>elixir有四个关键字很重要  <code>alias</code>  <code>require</code> <code>import</code> <code>use</code>具体意义参考官方说明文档</li>
</ul>
<figure class="highlight elixir"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Alias the module so it can be called as Bar instead of Foo.Bar</span></span><br><span class="line"><span class="keyword">alias</span> <span class="title class_">Foo</span>.<span class="title class_">Bar</span>, <span class="symbol">as:</span> <span class="title class_">Bar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Require the module in order to use its macros</span></span><br><span class="line"><span class="keyword">require</span> <span class="title class_">Foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Import functions from Foo so they can be called without the `Foo.` prefix</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Invokes the custom code defined in Foo as an extension point</span></span><br><span class="line"><span class="keyword">use</span> <span class="title class_">Foo</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>控制结构在erlang中有 <code>case</code> <code>if</code>，Elixir中有 <code>case</code> <code>if else</code> <code>unless</code> <code>cond</code> <code>with</code></li>
</ul>
<blockquote>
<p><code>cond</code> 类似于 erlang中的<code>if</code></p>
</blockquote>
<figure class="highlight elixir"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 重点说明with的用法，简化代码</span></span><br><span class="line"><span class="keyword">case</span> read_line(socket) <span class="keyword">do</span>  </span><br><span class="line"> {<span class="symbol">:ok</span>, data} -&gt;  </span><br><span class="line">	 <span class="keyword">case</span> <span class="title class_">KVServer</span>.<span class="title class_">Command</span>.parse(data) <span class="keyword">do</span>  </span><br><span class="line">		 {<span class="symbol">:ok</span>, command} -&gt;  </span><br><span class="line">				 <span class="title class_">KVServer</span>.<span class="title class_">Command</span>.run(command)  </span><br><span class="line">		 {<span class="symbol">:error</span>, _} = err -&gt;  </span><br><span class="line">				  err  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"> {<span class="symbol">:error</span>, _} = err -&gt;  </span><br><span class="line">  err  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># 使用with简化下</span></span><br><span class="line"> <span class="keyword">with</span> {<span class="symbol">:ok</span>, data} &lt;- read_line(socket),</span><br><span class="line">         {<span class="symbol">:ok</span>, command} &lt;- <span class="title class_">KVServer</span>.<span class="title class_">Command</span>.parse(data),</span><br><span class="line">         <span class="symbol">do:</span> <span class="title class_">KVServer</span>.<span class="title class_">Command</span>.run(command)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>字符串插值与字符串拼接<code>&lt;&gt;</code></li>
</ul>
<blockquote>
<p>iex&gt;  name  =  “Sean”<br>
iex&gt;  “Hello #{name}”<br>
“Hello Sean”<br>
"Hello "  &lt;&gt;  name<br>
“Hello Sean”</p>
</blockquote>
<ul>
<li>elixir  没有<code>andalso</code> <code>orelse</code> ；<code>and </code>  <code>or</code>  意义与erlang不同</li>
<li><code>and </code>  <code>or</code>  <code>||</code> <code>&amp;&amp;</code></li>
<li><code>and</code>，<code>or</code> 对应Erlang中的 <code>andalso</code> 和 <code>orelse</code> 操作符。所以它们不会计算第一个参数的值，而只会计算第二个参数</li>
<li><code>and</code>、<code>or</code>、<code>not</code>，它们的第一个参数_必须_是布尔类型（<code>true</code> 和 <code>false</code>）</li>
</ul>
<figure class="highlight elixir"><table><tbody><tr><td class="code"><pre><span class="line"><span class="literal">true</span> || <span class="string">"runtime error"</span>  <span class="comment"># true</span></span><br><span class="line"><span class="literal">false</span> || <span class="string">"runtime error"</span> <span class="comment"># "runtime error"</span></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="string">"runtime error"</span> <span class="comment">#  "runtime error"</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; <span class="string">"runtime error"</span> <span class="comment"># false </span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>map</li>
</ul>
 <figure class="highlight elixir"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="title class_">Erlang</span></span><br><span class="line"> M = <span class="comment">#{a =&gt; 1, 1 =&gt; 1000}.</span></span><br><span class="line"> <span class="comment">#{a := X, X := Z} = M</span></span><br><span class="line"> </span><br><span class="line"> <span class="title class_">Elixir</span></span><br><span class="line"> m = %{<span class="symbol">:a</span> =&gt; <span class="number">1</span>, <span class="number">1</span> =&gt; <span class="number">1000</span>}</span><br><span class="line"> m[m.a]</span><br><span class="line">存储键只有原子的映射，可以不用 `=&gt;`，直接使用关键字列表的语法：</span><br><span class="line"> x = %{<span class="symbol">foo:</span>  <span class="string">"bar"</span>,  <span class="symbol">hello:</span>  <span class="string">"world"</span>}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>^</code> 操作符, 使用 pin 操作符，我们就是用已经绑定的值去匹配，而不是重新绑定一个新值</li>
</ul>
<figure class="highlight elixir"><table><tbody><tr><td class="code"><pre><span class="line">iex&gt;  x  =  <span class="number">1</span>  </span><br><span class="line"><span class="number">1</span>  </span><br><span class="line">iex&gt;  ^x  =  <span class="number">2</span>  </span><br><span class="line">**  (<span class="title class_">MatchError</span>)  no  match  of  right  hand  side  <span class="symbol">value:</span>  <span class="number">2</span>  </span><br><span class="line">iex&gt;  {x,  ^x}  =  {<span class="number">2</span>,  <span class="number">1</span>}  </span><br><span class="line">{<span class="number">2</span>,  <span class="number">1</span>} </span><br><span class="line">iex&gt;  x  </span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2>
<ul>
<li>函数可以省略掉括号比如 fn x, y -&gt; x + y end</li>
<li>匿名函数</li>
</ul>
<figure class="highlight elixir"><table><tbody><tr><td class="code"><pre><span class="line">f =  <span class="keyword">fn</span>(x, y) -&gt; x + y <span class="keyword">end</span>;</span><br><span class="line">a = &amp;(&amp;<span class="number">1</span> + &amp;<span class="number">2</span>)</span><br><span class="line">f.(<span class="number">1</span>,<span class="number">2</span>)   </span><br><span class="line">a.(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>模块名首字母大写 Server.Listener</li>
<li>函数名后有?表示返回值为boolean 比如 def is_ok? -&gt; true end</li>
<li>函数名后有!</li>
</ul>
<figure class="highlight elixir"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 `var!/2` 可以让某个变量的操作变成对上下文变量的操作。</span></span><br><span class="line"><span class="comment"># `var!/2`，我们可以直接操作 `val` 变量而不需要它作为参数传递给宏。宏的这种使用方式应该尽少使用，引入 `var!/2` 会增加变量冲突的风险</span></span><br><span class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Example</span></span> <span class="keyword">do</span></span><br><span class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">hygienic</span></span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">quote</span> <span class="symbol">do:</span> val = <span class="number">-1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="function"><span class="keyword">defmacro</span> <span class="title">unhygienic</span></span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">quote</span> <span class="symbol">do:</span> var!(val) = <span class="number">-1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">然后比较一下它们是怎么和代码的上下文交互的：</span><br><span class="line">iex&gt; <span class="keyword">require</span> <span class="title class_">Example</span></span><br><span class="line"><span class="literal">nil</span></span><br><span class="line">iex&gt; val = <span class="number">42</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line">iex&gt; <span class="title class_">Example</span>.hygienic</span><br><span class="line"><span class="number">-1</span></span><br><span class="line">iex&gt; val</span><br><span class="line"><span class="number">42</span></span><br><span class="line">iex&gt; <span class="title class_">Example</span>.unhygienic</span><br><span class="line"><span class="number">-1</span></span><br><span class="line">iex&gt; val</span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>访问Erlang函数 :erlang:length([])</li>
<li>模块的函数不需要export，使用def定义为公共访问 defp 为私有</li>
</ul>
<figure class="highlight elixir"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">defmodule</span> <span class="title">Example</span></span> <span class="keyword">do</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">of_public</span></span> <span class="keyword">do</span></span><br><span class="line">		<span class="title class_">IO</span>.puts <span class="string">"public funtcion"</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="function"><span class="keyword">defp</span> <span class="title">of_private</span></span> <span class="keyword">do</span></span><br><span class="line">		<span class="title class_">IO</span>.puts <span class="string">"private function"</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Example</span>.of_public <span class="comment"># "public funtcion"</span></span><br><span class="line"><span class="title class_">Example</span>.of_private  <span class="comment"># ** (UndefinedFunctionError) function Example.of_private/0 is undefined or </span></span><br><span class="line"><span class="comment"># private Example.of_private()</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id=""><a class="markdownIt-Anchor" href="#"></a> 👍</h2>
<ul>
<li>pipeline</li>
</ul>
<h2 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> 👎</h2>
<ul>
<li>调用匿名函数需要加个<code>.</code></li>
</ul>
]]></content>
      <categories>
        <category>Erlang</category>
      </categories>
      <tags>
        <tag>Erlang</tag>
      </tags>
  </entry>
  <entry>
    <title>Erlang Garbage Collection</title>
    <url>/2017/12/24/ErlangGarbageCollection/</url>
    <content><![CDATA[<h1 id="garbage-collection"><a class="markdownIt-Anchor" href="#garbage-collection"></a> Garbage Collection</h1>
<p>Erlang的GC是分代复制，还有一个引用计数型的GC运行在共享堆（Binary&gt;64字节）上</p>
<h3 id="private-heap-gc-私有堆垃圾回收"><a class="markdownIt-Anchor" href="#private-heap-gc-私有堆垃圾回收"></a> Private Heap GC 私有堆垃圾回收</h3>
<p>私有堆的垃圾回收是分代的. 分代机制把进程的堆内存分为两个部分,年轻代和年老代. 区分是基于这样一个考虑, 如果一个对象在运行一次垃圾回收之后没有被回收,那么这个对象短期内被回收的可能性就很低. 所以, 年轻代就用来存储新分配的数据,年老代就用来存放运行一定次数的垃圾回收之后依然幸存的数据. 这样的区分可以帮助GC减少对那些很可能还不是垃圾的数据不必要的扫描. 对应于此, Erlang的GC扫描有两个策略, Generational(Minor) 和 Fullsweep(Major). Generational GC只回收年轻代的区域, 而Fullsweep则同时回收年轻代和年老代.</p>
<p><strong>场景 1</strong>:</p>
<figure class="highlight erlang"><table><tbody><tr><td class="code"><pre><span class="line">Spawn &gt; No GC &gt; Terminate</span><br></pre></td></tr></tbody></table></figure>
<p>假设一个生存期较短的进程, 在存活期间使用的堆内存也没有超过  _min_heap_size,_那么在进程结束是全部内存即被回收.</p>
<p><strong><strong>场景</strong> 2</strong>:</p>
<figure class="highlight erlang"><table><tbody><tr><td class="code"><pre><span class="line">Spawn &gt; Fullsweep &gt; Generational &gt; Terminate</span><br></pre></td></tr></tbody></table></figure>
<p>假设一个新创建的进程,当进程的数据增长超过了_min_heap_size_时, fullsweep GC即被触发, 因为在此之前还没有任何GC被触发,所以堆区还没有被分成年轻代和年老代. 在第一次fullsweep GC结束以后, 堆区就会被分为年轻代和年老代了, 从这个时候起, GC的策略就被切换为 generational GC了, 直到进程结束.</p>
<p><strong><strong>场景</strong> 3</strong>:</p>
<figure class="highlight erlang"><table><tbody><tr><td class="code"><pre><span class="line">Spawn &gt; Fullsweep &gt; Generational &gt; Fullsweep &gt; Generational &gt; ... &gt; Terminate</span><br></pre></td></tr></tbody></table></figure>
<p>在某些情景下, GC策略会从generation再切换回fullsweep. 一种情景是, 在运行了一定次数(fullsweep_after)的genereration GC之后,系统会再次切换回fullsweep. 这个参数fullsweep_after可以是全局的也可以是单进程的. 全局的值可以通过函数erlang:system_info(fullsweep_after)获取, 进程的可以通过函数erlang:process_info(self(),garbage_collection)来获取. 另外一种情景是, 当generation GC(minor GC)不能够收集到足够的内存空间时. 最后一种情况是, 当手动调用函数garbage_collector(PID)时. 在运行fullsweep之后, GC策略再次切换回generation GC直到以上的任意一个情景再次出现.</p>
<p><strong><strong>场景</strong> 4</strong>:</p>
<figure class="highlight erlang"><table><tbody><tr><td class="code"><pre><span class="line">Spawn &gt; Fullsweep &gt; Generational &gt; Fullsweep &gt; Increase Heap &gt; Fullsweep &gt; ... &gt; Terminate</span><br></pre></td></tr></tbody></table></figure>
<p>假设在场景3里面,第二个fullsweep GC依然没有回收到足够的内存, 那么系统就会为进程增加堆内存, 然后该进程就回到第一个场景,像刚创建的进程一样首先开始一个fullsweep,然后循环往复.</p>
<span id="more"></span>
<h3 id="shared-heap-gc-共享堆垃圾回收"><a class="markdownIt-Anchor" href="#shared-heap-gc-共享堆垃圾回收"></a> Shared Heap GC 共享堆垃圾回收</h3>
<ul>
<li>大于64个字节的二进制terms,被称为Reference Counted Binary。对Refc的binary进行sub binary的操作，是不会复制binary而是对二进制部分的引用，这种引用会增加原始bianry的引用计数，这可能会导致某些问题，比如有个100M的二进制，但是你只需要它的sub bianry 只有2M，因为sub binary 的原因会导致100M的二进制长时间释放不掉，这个时候最好使用copy，而不是使用sub binary相关的操作。</li>
<li>另外一个问题是长事件存活的中间进程（用于请求控制或者消息路由），这样中间进程转发的每个ProcBin 类型的每次转发都会增加原始binary的引用计数，但是由于ProcBin类型在进程内部仅仅是一个指针，所有可能会很长时间不会被释放，从而导致原始binary的引用计数不会减少，进而导致原始binary长时间不能被释放。关于Refc binary内存泄漏可以查看<a href="http://ferd.ca/">Fred Hebert</a> 的书 <a href="http://www.erlang-in-anger.com/">Erlang in Anger</a></li>
</ul>
<h3 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h3>
<p>erlang使用young heap 和old heap来区分数据，young heap放新数据，old heap放旧数据，也就是gc后存活的数据。<br>
<strong>浅扫描（minor collection）</strong><br>
在young heap中，erlang使用了高水位线来区分标记一次以上的数据和未标记的数据，那么young heap移入old heap的就是超过高水位线的数据。<br>
<img src="/images/MinorCollection.png" alt="minor collection"></p>
<p><strong>深扫描（major collection）</strong><br>
深扫描是一般当old heap空间不足时触发，erlang会对young heap和old heap做扫描，把有用的数据放入新申请的young heap，删掉原来的heap。深扫描的触发条件还有手动执行gc，和gc次数超过fullsweep_after的参数限定。<br>
<img src="/images/MajorCollectin.png" alt="minor collection"></p>
<h3 id="二进制数据垃圾回收机制"><a class="markdownIt-Anchor" href="#二进制数据垃圾回收机制"></a> 二进制数据垃圾回收机制</h3>
<p>heap binaries（大小不到 64 bytes，就直接存在进程堆内）和refc binaries（超过了64 bytes，就被保存到进程外的共享堆里，可以给节点内所有进程共享）。</p>
<ul>
<li>heap binaries</li>
</ul>
<blockquote>
<p>Heap binaries are small binaries, up to 64 bytes, that are stored directly on the process heap. They will be copied when the process is garbage collected and when they are sent as a message. They don’t require any special handling by the garbage collector.<br>
这部分二进制走的进程的GC，但是有个虚拟二进制堆(vheap)来计算这些二进制的使用情况，加快内存回收速度。</p>
</blockquote>
<ul>
<li>refc binaries</li>
</ul>
<blockquote>
<p>Refc binaries consist of two parts: an object stored on the process heap, called a ProcBin, and the binary object itself stored outside all process heaps.The binary object can be referenced by any number of ProcBins from any number of processes; the object contains a reference counter to keep track of the number of references, so that it can be removed when the last reference disappears.</p>
</blockquote>
<p>数据保存在进程外的共享堆，再把这个二进制数据的地址给拥有这个数据的进程。进程堆内保存的是这个二进制数据的引用，叫ProcBin。如果进程把这个二进制数据发给其他进程，erlang也不再复制整个二进制数据，而是直接再生成一份ProcBin到别的进程堆内。那么，这个二进制数据就可以多个进程的ProcBin引用，当没有一个ProcBin引用到这个二进制数据，这个二进制就被erlang回收。</p>
<blockquote>
<p>ProcBin是进程堆内数据，走的是进程堆数据的回收方式。</p>
</blockquote>
<ul>
<li>sub binary与match context</li>
</ul>
<blockquote>
<p>A sub binary is created by split_binary/2 and when a binary is matched out in a binary pattern. A sub binary is a reference into a part of another binary (refc or heap binary, never into a another sub binary). Therefore, matching out a binary is relatively cheap because the actual binary data is never copied.</p>
<p>A match context is similar to a sub binary, but is optimized for binary matching; for instance, it contains a direct pointer to the binary data. For each field that is matched out of a binary, the position in the match context will be incremented.</p>
</blockquote>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<ul>
<li>Erlang Garbage Collection Details and Why It Matters <a href="https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html">[原文]</a>   <a href="https://blog.csdn.net/swedenfeng/article/details/53897789">[翻译]</a></li>
<li><a href="https://blog.csdn.net/mycwq/article/details/26613275">Erlang进程堆垃圾回收机制</a></li>
<li><a href="https://blog.csdn.net/mycwq/article/details/26741387">Erlang二进制数据垃圾回收机制</a></li>
<li><a href="https://www.cnblogs.com/me-sa/archive/2011/11/13/erlang0014.html">Erlang 0014Erlang垃圾回收机制</a></li>
<li><a href="https://github.com/erlang/otp/blob/master/erts/emulator/internal_doc/GarbageCollection.md">官方文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Erlang</category>
        <category>gc</category>
      </categories>
      <tags>
        <tag>Erlang</tag>
        <tag>gc</tag>
      </tags>
  </entry>
  <entry>
    <title>Erlang Scheduler</title>
    <url>/2017/12/24/ErlangScheduler/</url>
    <content><![CDATA[<h1 id="erlang-scheduler"><a class="markdownIt-Anchor" href="#erlang-scheduler"></a> Erlang Scheduler</h1>
<table>
<thead>
<tr>
<th>Author</th>
<th>snail</th>
</tr>
</thead>
<tbody>
<tr>
<td>E-mail</td>
<td>**@qq.com</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B0%83%E5%BA%A6">什么是调度</a></li>
<li><a href="#Erlang%E8%B0%83%E5%BA%A6">Erlang调度</a></li>
<li><a href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E5%8E%86%E5%8F%B2">调度器的历史</a><br>
- <a href="#Before-R11B">Before R11B</a><br>
- <a href="#In-R11B-and-R12B">In R11B and R12B</a><br>
- <a href="#After-R13B">After R13B</a><br>
- <s><a href="#In-latest-Version">In latest Version</a></s></li>
<li><a href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E9%98%9F%E5%88%97">调度器队列</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E8%BF%81%E7%A7%BB/%E7%AA%83%E5%8F%96">进程迁移/窃取</a></li>
<li><a href="#%E6%8E%A7%E5%88%B6%E5%8F%82%E6%95%B0%E4%B8%8EAPI">控制参数与API</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E9%9B%B6%E7%A2%8E">其他零碎</a><br>
- <a href="#Reduction">Reduction </a><br>
- <a href="#Port">Port</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<hr>
<p>❗本文档中调度器调度的基本单位使用程序、活、任务等等，其实可以理解成 <strong>Work</strong>，<em>Work</em>可以是处于<a href="(/md/priv/ProcessStateMachine.png)">就绪状态</a>的<a href="http://erlang.org/doc/reference_manual/processes.html">进程</a>、 <a href="#Port">Port</a> 、系统事件等等</p>
<hr>
<h3 id="什么是调度"><a class="markdownIt-Anchor" href="#什么是调度"></a> 什么是调度</h3>
<ul>
<li>调度就是将工作分发给工作者，这些工作者可以是操作系统的线程<a href="https://en.wikipedia.org/wiki/Thread_%28computing%29">Native Threads</a>或<a href="https://en.wikipedia.org/wiki/Green_threads">Green Threads</a>。调度器分为两种：</li>
</ul>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Preemption_%28computing%29">抢占式</a><br>
<a href="https://en.wikipedia.org/wiki/Cooperative_multitasking">协作式</a></p>
</blockquote>
<p>两种方式各有优劣，我们重点关注<a href="https://en.wikipedia.org/wiki/Preemption_%28computing%29">抢占式</a> ，因为Erlang就是使用的这种方式。</p>
<span id="more"></span>
<h3 id="erlang调度"><a class="markdownIt-Anchor" href="#erlang调度"></a> Erlang调度</h3>
<p>Erlang的调度器运行两种任务：<a href="http://erlang.org/doc/reference_manual/processes.html">进程</a>任务和 <a href="#Port">Port</a> 任务，同时负责GC和内存管理。<br>
调度器职责是选择要执行的任务，该任务将执行一定时间。怎样选取？执行多长时间呢？<br>
调度器基于优先级选择要执行的进程，对于同一优先级的进程使用轮询的方式选择，另外还要根据<a href="#Reduction"><strong>Reductions</strong></a>来中断程序运行。reduction我们可以理解成一次函数调用就+1的一个计数器，当它达到最大值<a href="https://github.com/erlang/otp/blob/master/erts/emulator/beam/erl_vm.h#L39">CONTEXT_REDS</a>的时候，调度器将会中断当前进程进行上下文的切换，选取新的进程来执行。<br>
进程也根据一定策略(非常复杂)在调度器之间做<a href="#%E8%BF%9B%E7%A8%8B%E8%BF%81%E7%A7%BB/%E7%AA%83%E5%8F%96">平衡</a>，Erlang的调度器采用启发式算法在多个调度器之间平衡负载，以便充分利用所有CPU核心。默认策略是让低ID的调度器先跑满，然后在启动新的；当负载下降后，会关闭掉部分调度器，进入所谓的省电模式（说能省电，我都有点想笑😆）。⚡调度器会滞后启动或者停止，因为这两个操作的代价很大，只有在它真正需要的时候才这样做。 如果没有工作可做，调度器会自旋(Spin)等一会，期待有活到来，如果活儿来了，可以立马处理；如果没活儿那只能睡觉 😴。<br>
当执行了<a href="https://github.com/erlang/otp/blob/maint-19/erts/emulator/beam/erl_vm.h#L49">INPUT_REDUCTIONS</a>(OTP/19 这个值2*CONTEXT_REDS,但是在最新的OTP/21未找到这个值的定义)个reductions 或者没有可运行的进程，调度器将会收割系统底层事件(<a href="(https://github.com/erlang/otp/blob/maint-19/erts/emulator/beam/erl_process.c#L9844)">erl_sys_schedule</a>)</p>
<blockquote>
<p>❗关于调度的公平性可以参考霸爷的文章<a href="http://blog.yufeng.info/archives/3130">Erlang公平调度的误解</a><br>
简单说VM就是个超大的循环，基本上就是：</p>
<ol>
<li>拿消息</li>
<li>执行opcode或者nif,bif</li>
<li>收割os底层事件</li>
</ol>
<p>其中2在努力保证公平，但是1和3在设计层面不考虑公平<br>
取消息。 erlang的消息队列是单向队列实现的，消息是按照先来后到的顺序进来的，而且消息队列是没有保护的，只要对端原因扔消息，消息就会进入队列。匹配的时候，比如有N个匹配条件，M个消息，那么计算量是N*M。在极端的情况下，如果进程的消息处理能力跟不上，马上就会出现队列爆长，然后计算量和内存激增，最终导致VM奔溃。<br>
内存的使用。任何有意义的操作都差不多需要内存配合，而内存是从分配器中取的，虽然erlang设计了非常精巧的内存分配器，每个调度器都有个自己的池。但是凡是池子（Cache)，总有不满足的时候，这部分内存就需要向底层内存批发器比如mseg_alloc或者sys_alloc要，那就不可避免的用到了锁。这个锁的冲突导致的不公平就看业务模式和造化了。<br>
还有更多。这些东西都会破坏公平性，在实际的系统中会很严重，影响erlang的公平性声誉。所以最近erlang要引入dirty scheduler, native process等尝试都是为了减少这类问题造成的影响。<br>
架构师需要更多的了解系统和业务，如果可能的话，在业务层面也需要设计成更公平的系统</p>
</blockquote>
<h3 id="调度器的历史"><a class="markdownIt-Anchor" href="#调度器的历史"></a> 调度器的历史</h3>
<h4 id="before-r11b"><a class="markdownIt-Anchor" href="#before-r11b"></a> Before-R11B</h4>
<ul>
<li>Scheduler:Run Queue  1 : 1</li>
</ul>
<blockquote>
<p>这种方式无需对数据结构加锁，但同时也无法享受并发带来的好处</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">+--------------------------------------------------------+</span><br><span class="line">|  +-----------------+              +-----------------+  |</span><br><span class="line">|  |    Scheduler    +--------------&gt;     Task # 1    |  |</span><br><span class="line">|  +-----------------+              |     Task # 2    |  |</span><br><span class="line">|                                   |     Task # 3    |  |</span><br><span class="line">|                                   |     Task # N    |  |</span><br><span class="line">|                                   +-----------------+  |</span><br><span class="line">|                                   |    Run Queue    |  |</span><br><span class="line">|                                   +-----------------+  |</span><br><span class="line">+--------------------------------------------------------+</span><br></pre></td></tr></tbody></table></figure>
<h4 id="in-r11b-and-r12b"><a class="markdownIt-Anchor" href="#in-r11b-and-r12b"></a> In R11B and R12B</h4>
<ul>
<li>Scheduler:Run Queue  N : 1</li>
</ul>
<blockquote>
<p>对比前面的方式在多核系统上的性能提升<br>
❗随着调度器数量的增加，共享的运行队列会成为瓶颈<br>
❗增加了ETS锁的复杂度，进而影响Mnesia<br>
❗当多个进程向同一个进程发送消息是，锁冲突几率增加<br>
❗当一个进程在获取锁时会阻塞进程所在的调度器</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">+--------------------------------------------------------+</span><br><span class="line">|  +-----------------+              +-----------------+  |</span><br><span class="line">|  |  Scheduler # 1  +--------------&gt;     Task # 1    |  |</span><br><span class="line">|  |                 |    +---------&gt;                 |  |</span><br><span class="line">|  +-----------------+    |    +----&gt;     Task # 2    |  |</span><br><span class="line">|  +-----------------+    |    |    |     Task # 3    |  |</span><br><span class="line">|  |  Scheduler # 2  +----+    |    |     Task # 4    |  |</span><br><span class="line">|  +-----------------+         |    |     Task # N    |  |</span><br><span class="line">|  +-----------------+         |    +-----------------+  |</span><br><span class="line">|  |  Scheduler # N  +---------+    |    Run Queue    |  |</span><br><span class="line">|  +-----------------+              +-----------------+  |</span><br><span class="line">+--------------------------------------------------------+</span><br></pre></td></tr></tbody></table></figure>
<h4 id="after-r13b"><a class="markdownIt-Anchor" href="#after-r13b"></a> After R13B</h4>
<ul>
<li>Scheduler:Run Queue  N : N</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">+--------------------------------------------------------+</span><br><span class="line">|  +-----------------+-----------------+                 |</span><br><span class="line">|  |  Scheduler # 1  |  Run Queue # 1  &lt;--+              |</span><br><span class="line">|  +-----------------+-----------------+  |              |</span><br><span class="line">|  +-----------------+-----------------+  |              |</span><br><span class="line">|  |  Scheduler # 2  |  Run Queue # 2  &lt;--|-&gt; Migration  |</span><br><span class="line">|  +-----------------+-----------------+  |   Logic      |</span><br><span class="line">|  +-----------------+-----------------+  |              |</span><br><span class="line">|  |  Scheduler # N  |  Run Queue # N  &lt;--+              |</span><br><span class="line">|  +-----------------+-----------------+                 |</span><br><span class="line">+--------------------------------------------------------+</span><br></pre></td></tr></tbody></table></figure>
<h3 id="调度器循环"><a class="markdownIt-Anchor" href="#调度器循环"></a> 调度器循环:</h3>
<p>❗从理解的角度上看，可将<a href="https://github.com/erlang/otp/blob/master/erts/emulator/beam/erl_process.c#L9198">调度器循环 erts_schedule</a>理解成如下所示(<a href="https://happi.github.io/theBeamBook/#_the_scheduler_loop">Link</a>)：</p>
<ol>
<li>Update reduction counters.</li>
<li>Check timers</li>
<li>If needed <a href="https://github.com/erlang/otp/blob/master/erts/emulator/beam/erl_process.c#L4637">check balance</a></li>
<li>If needed migrate processes and ports</li>
<li>Do auxiliary scheduler work</li>
<li>If needed check IO and update time</li>
<li>While needed pick a port task to execute</li>
<li>Pick a process to execute</li>
</ol>
<h3 id="调度器队列"><a class="markdownIt-Anchor" href="#调度器队列"></a> 调度器队列</h3>
<p>目前有个四个队列（优先级)  <code>low</code>  <code>normal</code>  <code>high</code> <code>max</code>，队列里的进程全部处于<a href="/md/priv/ProcessStateMachine.png">runnable</a>状态</p>
<blockquote>
<p>❗ 总结来自于<a href="http://erlang.org/pipermail/erlang-questions/">Erlang MailList</a>中的问题<a href="http://erlang.org/pipermail/erlang-questions/2001-April/003132.html">Erlang Scheduler: what does it do</a>，可能已经过时后面再根据最新文档做修正</p>
</blockquote>
<ul>
<li>调度器优先选择 <code>max</code>队列里的进程执行；如果该队列为空则选择<code>high</code>队列里的进程来执行</li>
<li><code>normal</code> <code>low</code>具有公平属性。假设没有进程在<code>max</code> <code>high</code>队列里，当<code>normal</code>队列所有进程全部执行完或者执行了 8*<a href="https://github.com/erlang/otp/blob/master/erts/emulator/beam/erl_vm.h#L39">CONTEXT_REDS</a>才会选择<code>low</code>队列里的进程执行；但是也有例外，比如<code>normal</code>队列里有数百个进程，但是<code>low</code>队列里进程只有很少的几个，这种情况下<code>low</code>队列里进程会优先执行</li>
</ul>
<blockquote>
<p>❗ 根据<a href="https://happi.github.io/theBeamBook/#_process_queues">Process Queues</a>做部分修正</p>
</blockquote>
<ul>
<li>每个调度器有三个队列分别是 <code>low normal</code>  <code>high</code> <code>max</code></li>
<li><code>max</code> <code>high</code>跟前面的一样</li>
<li><code>low normal</code> 有差别。当进程被放入<code>normal</code>队列是获得一个调度器计数（<em>schedule count</em>）1，被放入<code>low</code>获得一个调度器计数8，从队首取出进程时，将调度器计数减1，计数为0进程被调度，否则就被放到队尾</li>
</ul>
<h3 id="进程迁移窃取"><a class="markdownIt-Anchor" href="#进程迁移窃取"></a> 进程迁移/窃取</h3>
<p>❗ <a href="http://erlang.org/euc/08/euc_smp.pdf">Inside the Erlang VM</a><br>
❗ <a href="https://happi.github.io/theBeamBook/#_load_balancing">Load Balancing</a></p>
<blockquote>
<p>负载均衡器的当前策略是尽可能少地使用调度程序而不会使任何CPU过载。<br>
每个在online的调度的每个优先级都会执行如下操作<br>
内部实现更为复杂(特别是牵涉到进程优先级，可以调度器集成 offline等等)我们可以简单理解成：</p>
</blockquote>
<ul>
<li>迁移</li>
</ul>
<blockquote>
<p>迁移首先是通过设置一个迁移计划，让调度器在该计划上执行直到设置下一个计划，每个运行<a href="https://github.com/erlang/otp/blob/master/erts/emulator/beam/erl_process.c#L61">2000*[CONTEXT_REDS]</a>规约（reductions），调度程序通过查看所有调度程序的工作负载来计算每个调度器的每个优先级的迁移路径。迁移路径有三种值:</p>
<ol>
<li>cleared</li>
<li>migrate to scheduler</li>
<li>immigrate from scheduler</li>
</ol>
<p>当一个进程处于就绪状态时，假设最后一次调度该进程的调度器（S1）<br>
如果该进程优先级的迁移路径被 cleared，那么该进程运行于S1<br>
如果S1调度器的迁移（migrate ）路径被设置成（S2），且S1与S2的run queue 都不平衡，那么该进程可能会被迁移到S2<br>
当S1选取一个进程执行时，它检查移民路径(immigration path)，如果被设置成S2且S1与S2的run queue 都不平衡，那么S1可能会从S2窃取一个进程</p>
<p>通过比较每个调度程序的特定优先级的最大运行队列来计算迁移路径，每次调度器loop都会更新run queue的长度，这些值用于计算run queue的平均（最大）长度<br>
run queue长度低于平均长度的调度器会被标记成 immigration，当该调度器会从别的高负载的调度器迁入任务<br>
run queue长度高于平均长度会被标记成emigration，进程会从这个调度器迁移出去</p>
<p>有两种情况会忽略上面的标记做强制迁移，</p>
<ol>
<li>调度器offline</li>
<li>调度器检测到某些优先级的任务一直没有运行</li>
</ol>
</blockquote>
<ul>
<li>窃取</li>
</ul>
<blockquote>
<p>如果一个调度器的run queue为空的时候，该调度器将会尝试从别的调度器窃取任务<br>
首先该调度器会锁住自己，防止别的调度器窃取自己的任务<br>
然后该调度器会检查是否有可以被窃取任务的非活跃的调度器(inactive schedulers) ，如果没有<br>
在从ID比自己大的活跃调度器开始尝试窃取一个任务<br>
每次查看一个调度器，然后尝试窃取目标调取最高优先级的任务<br>
找到可以窃取的任务就把该任务从别的调度器移动到当前调度器<br>
👍 任务窃取的效率很高，所以当一个调度器没有工作可做时，在每次调度器loop中都会执行</p>
</blockquote>
<h3 id="控制参数与api"><a class="markdownIt-Anchor" href="#控制参数与api"></a> 控制参数与API</h3>
<blockquote>
<p>❗ 需要在启动节点时通过运行参数才能生效<br>
❗ 最大调度器数（MaxAvailableSchedulers）和可用调度器数（OnlineSchedulers）</p>
</blockquote>
<ul>
<li><a href="http://erlang.org/doc/man/erl.html#+S">+S MaxAvailableSchedulers:OnlineSchedulers</a></li>
<li><a href="http://erlang.org/doc/man/erl.html#+SP">+SP</a> 可以以百分比形式设定以上参数</li>
<li><a href="http://erlang.org/doc/man/erl.html#+sbt">+sbt</a> 可以绑定调度器到CPU的某个核心上，这样调度器就不会在CPU核心切换</li>
<li><a href="http://erlang.org/doc/man/erl.html#+sub">+sub</a> 让所有调度器都参与工作，而且会做平衡</li>
<li><a href="http://erlang.org/doc/man/erl.html#+scl">+scl</a>  <em>true</em>通过迁移把任务集中让调度器全速工作，不够用就开启别的调度器</li>
<li><a href="http://erlang.org/doc/man/erl.html#+IOp">+IOp</a> 文件描述符的轮询集的数量 <a href="http://blog.yufeng.info/archives/2998">问题描述</a></li>
<li><a href="http://erlang.org/doc/man/erl.html#+IOt">+IOt</a> 控制投递事件线程数量<a href="http://blog.yufeng.info/archives/2998">问题描述</a></li>
<li><a href="http://erlang.org/doc/man/erl.html">+A</a> 异步线程池线程数量</li>
</ul>
<blockquote>
<p>异步线程池是供驱动器使用的，主要是防止Driver的操作长时间占用Erlang虚拟机<br>
❗ 仅供 file driver 或者用户自己实现的driver使用，所以有大量文件操作可以增大此参数</p>
</blockquote>
<ul>
<li><code>erlang:system_info/1</code>  <code>schedulers | schedulers_online</code></li>
<li><code>erlang:system_flag/2</code>  <code> schedulers_online, OnlineSchedulers</code></li>
<li><code>erlang:statistics(run_queue)</code>统计运行队列中存放了已经就绪但尚未被调度器执行的进程</li>
</ul>
<h3 id="其他零碎"><a class="markdownIt-Anchor" href="#其他零碎"></a> 其他零碎</h3>
<h4 id="reduction"><a class="markdownIt-Anchor" href="#reduction"></a> Reduction</h4>
<blockquote>
<p>每个进程或者ports每次获得<a href="https://github.com/erlang/otp/blob/master/erts/emulator/beam/erl_vm.h#L39">CONTEXT_REDS</a>个reductions。任何操作都会消耗reductions，比如函数调用、调用BIFs(built-in-functions )、进程GC、读写ETS、发送消息（如果收消息的进程邮箱中消息越多消耗越高）、发送分布式消息、Port的I/O操作等等都会消耗进程的reductions。总之进程一切操作都会消耗reductions<a href="https://happi.github.io/theBeamBook/#_reductions_2">More</a></p>
</blockquote>
<h4 id="port"><a class="markdownIt-Anchor" href="#port"></a> Port</h4>
<blockquote>
<p>Port是Erlang与外部世界沟通交流的一种机制，比如 Files、Socket、面向其他程序的Pipe都称之为Port，我们可以用C代码自己给Erlang增加新的 "port drivers"<a href="http://erlang.org/doc/reference_manual/ports.html">More</a></p>
</blockquote>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<ul>
<li><a href="http://jlouisramblings.blogspot.co.uk/2013/01/how-erlang-does-scheduling.html">How Erlang Does Scheduling</a></li>
<li><a href="https://hamidreza-s.github.io/erlang/scheduling/real-time/preemptive/migration/2016/02/09/erlang-scheduler-details.html">Erlang Scheduler Details and Why It Matters</a> <a href="https://blog.csdn.net/qq_31369609/article/details/51834576">中文</a></li>
<li><a href="http://erlang.org/euc/08/euc_smp.pdf">Inside the Erlang VM</a></li>
<li><a href="http://erlang.org/pipermail/erlang-questions/2001-April/003132.html">Erlang Scheduler: What Does It Do</a></li>
<li><a href="https://blog.yufeng.info/archives/3149">R17新的调度策略+sub</a></li>
<li><a href="http://blog.yufeng.info/archives/2998">Erlang网络密集型服务器的瓶颈和解决思路</a></li>
<li><a href="http://blog.yufeng.info/archives/3130">Erlang公平调度的误解</a></li>
<li><a href="https://happi.github.io/theBeamBook/#CH-Scheduling">Scheduling</a></li>
<li><a href="http://www.erlang-factory.com/static/upload/media/14979662889302503kennethlundinerlangvmnewsregardingdirtyschedulersandio.pdf">Erlang VM News Regarding Dirty Schedulers and I/O</a></li>
</ul>
]]></content>
      <categories>
        <category>Erlang</category>
      </categories>
      <tags>
        <tag>Erlang</tag>
      </tags>
  </entry>
  <entry>
    <title>Memory Allocator</title>
    <url>/2017/12/24/ErlangMemoryAllocator/</url>
    <content><![CDATA[<h1 id="memory-allocator"><a class="markdownIt-Anchor" href="#memory-allocator"></a> Memory Allocator</h1>
<h3 id="blocks"><a class="markdownIt-Anchor" href="#blocks"></a> blocks</h3>
<p>block是Erlang VM需要的一块连续的内存，比如向ets中插入的数据会变成一个block，Erlang进程的stack和heap 也是一个block；进程间发送的消息在block内被复制。总是block就是一块连续的C 内存。block也是Erlang Allocator内存分配的基本单位。</p>
<h3 id="carriers"><a class="markdownIt-Anchor" href="#carriers"></a> carriers</h3>
<p>carriers 是一个包含一个或者多个block的容器，carrier结构中有个头部，用于标识carrier的类型等等<br>
carrier是18bit对齐的（所以最小值是256KB）</p>
<h3 id="single-block-carriers-and-multi-block-carriers"><a class="markdownIt-Anchor" href="#single-block-carriers-and-multi-block-carriers"></a> single-block carriers and multi-block carriers</h3>
<blockquote>
<p>single-block carrier 就是只包含一个block的carrier<br>
multi-block carrier 包含多个block的carrier<br>
将大小超过一定阈值（ +sbct(single block carrier threshol)）的block放于一个single-block carrier；否则block会被放于一个 multi-block carrier中，这个阈值多大算大，是根据各个实际应用场景来决定的，有些情况下256字节就算很大，有些情况下可能5MB才算大；所以要根据应用场景来调整该值。默认值是512KB(The default is half MB)<br>
一般情况来讲，所有至少80%-90%的数据的都应该在multi-block carrier，</p>
</blockquote>
<span id="more"></span>
<p><code>When manipulating the threshold you probably also want to change the size of carriers that are being   allocated. So if you are increasing the size of individual blocks, you will wanting increase the actual   carriers that are being created. So if you increase the threshold to 1 MB, the.. I believe the default size   of multiblock carriers is 2 MB, the smallest one, and it grows up into 8 MB, depending on how many carriers   you have.Since you doubled the initial amount, you might want to double the next one as well, so you   started at 4 MB might grow up to 16 MB, or something of that effect.  </code></p>
<h3 id="main-multi-block-carrier"><a class="markdownIt-Anchor" href="#main-multi-block-carrier"></a> main multi-block carrier</h3>
<p>每个allocator实例都有创建 一个 不会被销毁的 “main multiblock carrier”, 这个carrier的大小由mmbcs指定</p>
<h3 id="super-carrier"><a class="markdownIt-Anchor" href="#super-carrier"></a> super carrier</h3>
<p>在R16B03加入，在启动时分配很大一块内存供虚拟机使用的 <strong>+MMsc系列参数设定</strong></p>
<blockquote>
<p>加入这个的原因参考- <a href="https://www.cnblogs.com/zhengsyao/p/erts_allocators_speech_by_lukas_larsson.html">Erlang 虚拟机内的内存管理_Lukas Larsson）</a>,大概是一个客户在启动阶段调用malloc耗时20秒</p>
</blockquote>
<h3 id="内存carrier迁移"><a class="markdownIt-Anchor" href="#内存carrier迁移"></a> 内存carrier迁移</h3>
<p><a href="https://github.com/erlang/otp/blob/master/erts/emulator/internal_doc/CarrierMigration.md">More</a></p>
<h3 id="allocators"><a class="markdownIt-Anchor" href="#allocators"></a> allocators</h3>
<p><img src="/images/Allocators.png" alt="system allocators"></p>
<ul>
<li>eheap_alloc(heap)、binary_alloc(binary)、driver_alloc(driver)、ets_alloc(ets) 这几个分配器可供我们调优</li>
<li>temp_alloc(temporary)、sl_alloc(short lived)、std_alloc(standard lived)、ll_alloc(long lived)、 fix_alloc(fix size) 是模拟器内部使用的。</li>
</ul>
<blockquote></blockquote>
<table>
<thead>
<tr>
<th>allocator</th>
<th>types</th>
</tr>
</thead>
<tbody>
<tr>
<td>temp_alloc</td>
<td><code>c函数</code> <code>temp gc rootset</code> <code>dist msg decode</code></td>
</tr>
<tr>
<td>sl_alloc</td>
<td><code>ets match specs</code> <code>short timers</code> <code>fs select list</code></td>
</tr>
<tr>
<td>std_alloc</td>
<td><code>links</code> <code>monitors</code></td>
</tr>
<tr>
<td>ll_alloc</td>
<td><code>code</code> <code>atoms</code></td>
</tr>
<tr>
<td>fix_alloc</td>
<td><code>process control block</code>  <code>port control block</code></td>
</tr>
<tr>
<td>eheap_alloc</td>
<td><code>heap</code> <code>list</code> <code>tuple</code></td>
</tr>
<tr>
<td>binary_alloc</td>
<td><code>binary</code></td>
</tr>
<tr>
<td>driver_alloc</td>
<td><code>driver</code></td>
</tr>
<tr>
<td>ets_alloc</td>
<td><code>ets</code></td>
</tr>
<tr>
<td>…</td>
<td><code>...</code></td>
</tr>
<tr>
<td>更多更具体的在<a href="https://github.com/erlang/otp/blob/master/erts/emulator/beam/erl_alloc.types">这里</a></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="分配策略"><a class="markdownIt-Anchor" href="#分配策略"></a> 分配策略</h3>
<table>
<thead>
<tr>
<th>Block oriented</th>
<th>Carrier oriented</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>best fit</code></td>
<td><code>address order first fit carrier best fit</code></td>
</tr>
<tr>
<td><code>address order best fit</code></td>
<td><code>address order first fit  carrier address order best  fit</code></td>
</tr>
<tr>
<td><code>address order first fit</code></td>
<td></td>
</tr>
<tr>
<td><code>good fit</code></td>
<td></td>
</tr>
<tr>
<td><code>a fit</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="carrier-allocators"><a class="markdownIt-Anchor" href="#carrier-allocators"></a> Carrier Allocators</h3>
<ul>
<li>mseg_alloc</li>
<li>sys_alloc</li>
</ul>
<h3 id="statistics"><a class="markdownIt-Anchor" href="#statistics"></a> Statistics</h3>
<ul>
<li>erlang:system_info({allocator,Type})</li>
</ul>
<blockquote>
<p>大部分显示一目了然<br>
blocks、blocks_size、carriers、carriers_size 都是一个三元组{_, Current, Max(Last),Max}<br>
block_size 可以理解成使用的内存<br>
carriers_size 可以理解成Erlang向系统申请的内存</p>
</blockquote>
<h3 id="mbcs_pool以及carrier-迁移"><a class="markdownIt-Anchor" href="#mbcs_pool以及carrier-迁移"></a> mbcs_pool以及Carrier 迁移</h3>
<blockquote>
<p>carrier迁移只能同类型的分配器之间进行(Migration of carriers of same type )</p>
</blockquote>
<ul>
<li><a href="http://erlang.org/doc/man/erts_alloc.html#M_acul">+M acul de</a> <a href="https://github.com/erlang/otp/blob/master/erts/emulator/beam/erl_alloc.c#L1301">默认值 get_acul_value</a></li>
<li>解决的问题</li>
</ul>
<blockquote>
<p>各种类型的分配器在每个调度器中都有个实例，如果某个调度器没有工作，那么在整个VM看来内存碎片率很高，我们在设  计系统的时候，通常从数据量去反推需要的内存，但是如果有碎片或者浪费存在严重的话，我们就无法准确，就可能导致灾  难。 为了解决这个问题，最直接的反应就是当每个调度器池子里面的内存使用率低于一定程度的时候，就把该块内存出让出  来，让有需要的调度器能够利用起来。这就是内存carriers迁移要解决的核心问题。</p>
</blockquote>
<ul>
<li>带来的影响</li>
</ul>
<blockquote>
<p>内存申请的效率将会受到影响(降低)，先在自己的池子里找，不满足就去 cpool找，在不满足就向系统要<br>
内部不仅在自己的池子里，还在cpool里，所以统计内存使用很麻烦，但是可用<a href="https://github.com/ferd/recon">recon</a></p>
</blockquote>
<ul>
<li>更详细解释在<a href="https://github.com/erlang/otp/blob/master/erts/emulator/internal_doc/CarrierMigration.md">这里</a><br>
<img src="/images/MemoryArchitecture.png" alt="Memory Architecture"></li>
</ul>
<h3 id="其他零碎"><a class="markdownIt-Anchor" href="#其他零碎"></a> 其他零碎</h3>
<ul>
<li>每种类型的分配器在每个调度器里都有个实例(参考<a href="#mbcs_pool">mbcs_pool</a>）</li>
<li>ID为0分配器实例是异步线程(async threads)使用的全局分配器</li>
<li>ID为1分配器实例是调度器1(scheduler 1)的实例，以此类推</li>
<li></li>
</ul>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<ul>
<li><a href="https://github.com/erlang/otp/blob/master/erts/emulator/internal_doc/CarrierMigration.md">CarrierMigration</a></li>
<li><a href="http://erlang.org/doc/man/erts_alloc.html">erts_alloc</a></li>
<li><a href="http://blog.yufeng.info/archives/3118">Erlang内存分配器之mbcs_pool</a></li>
<li><a href="http://blog.yufeng.info/archives/2946">R16B03新增加super carrier来减少mmap的系统调用</a></li>
<li><a href="https://www.cnblogs.com/zhengsyao/p/erts_allocators_speech_by_lukas_larsson.html">Erlang 虚拟机内的内存管理_Lukas Larsson）</a></li>
<li><a href="https://blog.heroku.com/logplex-down-the-rabbit-hole">Troubleshooting Down the Logplex Rabbit Hole</a></li>
</ul>
]]></content>
      <categories>
        <category>Erlang</category>
        <category>memory allocator</category>
      </categories>
      <tags>
        <tag>Erlang</tag>
      </tags>
  </entry>
  <entry>
    <title>Erlang节点互联</title>
    <url>/2017/12/24/ErlangNodeConnect/</url>
    <content><![CDATA[<h1 id="erlang节点互联"><a class="markdownIt-Anchor" href="#erlang节点互联"></a> Erlang节点互联</h1>
<h2 id="epmd"><a class="markdownIt-Anchor" href="#epmd"></a> epmd</h2>
<ul>
<li>Epmd是Erlang Port Mapper Daemon的缩写，在Erlang集群中的作用相当于dns的作用，提供节点名称到端口的查询服务，epmd默认绑定4369端口，可以通过设置环境变量 ERL_EPMD_PORT=XXX或者 erl -epmd_port NNNN 来修改次端口</li>
<li>epmd文档：<a href="http://www.erlang.org/doc/man/epmd.html">这里</a></li>
<li>epmd协议：<a href="http://www.erlang.org/doc/apps/erts/erl_dist_protocol.html">这里</a></li>
</ul>
<blockquote>
<p><img src="http://erlang.org/doc/apps/erts/erl_ext_fig.gif" alt="enter image description here"><br>
<img src="/images/epmd.png" alt="enter image description here"></p>
</blockquote>
<ul>
<li>net_kernel会启动proto_dist比如说inet_tcp_dist监听端口,同时把端口报到epmd. 这时候erts就准备好了节点通讯。这时候另外一个节点要和我们通讯的时候，首先要连接，流程大概是这样的：</li>
</ul>
<ol>
<li>根据节点名找到节点地址。</li>
<li>查询节点的4369端口,也就是epmd,向它要节点对应的inet_tcp_dist监听的端口。</li>
<li>发起连接, 握手，cookie认证，如果未授权就失败。</li>
<li>记录节点名称和响应的信息。</li>
</ol>
<span id="more"></span>
<h2 id="net_kernel"><a class="markdownIt-Anchor" href="#net_kernel"></a> net_kernel</h2>
<ul>
<li>重点关注 <strong>net_ticktime</strong>参数</li>
</ul>
<blockquote>
<p>节点会在每TickTime/4 秒检查一下连接的节点是不是正常，如果连续4次没有收到(TickTime时间内)没有收到心跳消息，就会认为这个节点挂了</p>
</blockquote>
<p>Specifies the net_kernel tick time. TickTime is given in seconds. Once every TickTime/4 second, all connected nodes are ticked (if anything else has been written to a node) and if nothing has been received from another node within the last four (4) tick times that node is considered to be down. This ensures that nodes which are not responding, for reasons such as hardware errors, are considered to be down.<br>
The time T, in which a node that is not responding is detected, is calculated as: MinT &lt; T &lt; MaxT where:<br>
MinT = TickTime - TickTime / 4<br>
MaxT = TickTime + TickTime / 4<br>
TickTime is by default 60 (seconds). Thus, 45 &lt; T &lt; 75 seconds.<br>
<strong>Note:</strong>  All communicating nodes should have the same TickTime value specified.<br>
<strong>Note:</strong>  Normally, a terminating node is detected immediately.</p>
<p><a href="http://erlang.org/doc/man/net_kernel.html">net_kernel</a><br>
<a href="http://www.erlang.org/doc/man/kernel_app.html">kernel_app</a></p>
<h2 id="节点互联失败排查"><a class="markdownIt-Anchor" href="#节点互联失败排查"></a> 节点互联失败排查</h2>
<blockquote>
<p>检查节点cookie<br>
检查otp版本<br>
检查机器网络<br>
检查epmd端口<br>
检查节点是否被禁用net_kernel:allowed()</p>
</blockquote>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<p><a href="http://blog.yufeng.info/archives/539">Erlang epmd的角色以及使用</a><br>
<a href="https://www.cnblogs.com/zhongwencool/p/erlang_nodedown.html">怎样模拟节点互连后的各种失败情况</a><br>
<a href="https://mryufeng.iteye.com/blog/120666">net_adm:ping(Node)发生了什么</a></p>
]]></content>
      <categories>
        <category>Erlang</category>
      </categories>
      <tags>
        <tag>Erlang</tag>
      </tags>
  </entry>
  <entry>
    <title>Erlang Process</title>
    <url>/2017/12/24/ErlangProcess/</url>
    <content><![CDATA[<h1 id="process"><a class="markdownIt-Anchor" href="#process"></a> Process</h1>
<h3 id="什么是进程"><a class="markdownIt-Anchor" href="#什么是进程"></a> 什么是进程</h3>
<p>这里的进程不是指操作系统意义上的进程，而是一个孤立的实体，进程是运行你的代码的地方，通过将错误的影响隔离到执行错误代码的进程，进程可以保护系统免受代码错误的影响。</p>
<h3 id="进程内存"><a class="markdownIt-Anchor" href="#进程内存"></a> 进程内存</h3>
<p>进程的内存分为四个部分：栈、堆、邮箱、进程控制块（Process Control Block）。</p>
<blockquote>
<p>可以用使用查看内部表示，但是这些仅仅用来调试或者理解内部机制用<br>
hipe_bifs:show_estack/1、 hipe_bifs:show_nstack/1、hipe_bifs:show_heap/1、<br>
hipe_bifs:show_pcb/1、 hipe_bifs:show_term/1</p>
</blockquote>
<ul>
<li>可以参考下面两张图理解</li>
</ul>
<span id="more"></span> 
<p><img src="/images/ProcessMemory.png" alt="进程内存"></p>
<figure class="highlight erlang"><table><tbody><tr><td class="code"><pre><span class="line">           Shared Heap                        Erlang Process Memory Layout                  </span><br><span class="line">                                                                                            </span><br><span class="line">+----------------------------------+      +----------------------------------+              </span><br><span class="line">|                                  |      |                                  |              </span><br><span class="line">|                                  |      |  PID / Status / Registered Name  |       Process</span><br><span class="line">|                                  |      |                                  |       Control</span><br><span class="line">|                                  |      |   Initial Call / Current Call    +----&gt;  Block  </span><br><span class="line">|                                  |      |                                  |       (PCB)  </span><br><span class="line">|                                  |      |         Mailbox Pointers         |              </span><br><span class="line">|                                  |      |                                  |              </span><br><span class="line">|                                  |      +----------------------------------+              </span><br><span class="line">|                                  |      |                                  |              </span><br><span class="line">|                                  |      |        Function Parameters       |              </span><br><span class="line">|                                  |      |                                  |       Process</span><br><span class="line">|                                  |      |         Return Addresses         +----&gt;  Stack  </span><br><span class="line">|                                  |      |                                  |              </span><br><span class="line">|    +--------------+              |      |         Local Variables          |              </span><br><span class="line">|    |              |              |      |                                  |              </span><br><span class="line">|    | +------------+--+           |      +-------------------------------+--+              </span><br><span class="line">|    | |               |           |      |                               |  |              </span><br><span class="line">|    | | +-------------+--+        |      |  ^                            v  +----&gt;  Free   </span><br><span class="line">|    | | |                |        |      |  |                               |       Space  </span><br><span class="line">|    | | | +--------------+-+      |      +--+-------------------------------+              </span><br><span class="line">|    +-+ | |                |      |      |                                  |              </span><br><span class="line">|      +-+ |  Refc Binary   |      |      |  Mailbox Messages (Linked List)  |              </span><br><span class="line">|        +-+                |      |      |                                  |              </span><br><span class="line">|          +------^---------+      |      |  Compound Terms (List, Tuples)   |       Process</span><br><span class="line">|                 |                |      |                                  +----&gt;  Private</span><br><span class="line">|                 |                |      |     Terms Larger than a word     |       Heap   </span><br><span class="line">|                 |                |      |                                  |              </span><br><span class="line">|                 +--+ ProcBin +-------------+ Pointers to Large Binaries    |              </span><br><span class="line">|                                  |      |                                  |              </span><br><span class="line">+----------------------------------+      +----------------------------------+              </span><br></pre></td></tr></tbody></table></figure>
<h3 id="进程控制块"><a class="markdownIt-Anchor" href="#进程控制块"></a> 进程控制块</h3>
<p>记录进程的各种信息的一个结构，这个结构的每个字段记录着进程状态，对应源代码中有个叫做<code>process</code>的结构体，该结构体位于<a href="https://github.com/erlang/otp/blob/OTP-19.3/erts/emulator/beam/erl_process.h"><code>erl_process.h</code></a></p>
<ul>
<li>PCB 内部结构以及部分字段的含义</li>
</ul>
<figure class="highlight erlang"><table><tbody><tr><td class="code"><pre><span class="line">---------------------------------------------------------------</span><br><span class="line">Offset| Name        | Value              | *Value             |</span><br><span class="line">    0 | id          | 0x000001d0000003a3 |PID             </span><br><span class="line">   72 | htop        | 0x00007f7f33f15298 |pointers to the top of the heap                   </span><br><span class="line">   96 | hend        | 0x00007f7f33f16540 |points to the stop of the whole heap                  </span><br><span class="line">   88 | heap        | 0x00007f7f33f11470 |points to heap start                 </span><br><span class="line">  104 | heap_sz     | 0x0000000000000a1a | gives the size of the heap in words <span class="params">(hend - heap = heap_sz * <span class="number">8</span> on a <span class="number">64</span> bit machine )</span>                    </span><br><span class="line">   80 | stop        | 0x00007f7f33f16480 |pointers to the top of the stack                   </span><br><span class="line">  592 | gen_gcs     | 0x0000000000000012 |Number of <span class="params">(minor)</span> generational GCs.</span><br><span class="line">  <span class="number">594</span> | max_gen_gcs | <span class="number">0</span>x000000000000ffff |Max minor gen GCs before fullsweep.</span><br><span class="line">  <span class="number">552</span> | high_water  | <span class="number">0</span>x00007f7f33f11c50 |                    |</span><br><span class="line">  <span class="number">560</span> | old_hend    | <span class="number">0</span>x00007f7f33e90648 |                    |</span><br><span class="line">  <span class="number">568</span> | old_htop    | <span class="number">0</span>x00007f7f33e8f8e8 |                    |</span><br><span class="line">  <span class="number">576</span> | old_head    | <span class="number">0</span>x00007f7f33e8e770 |                    |</span><br><span class="line">  <span class="number">112</span> | min_heap_size | <span class="number">0</span>x00000000000000e9 |in words, that the heap starts with <span class="keyword">and</span> which it will <span class="keyword">not</span> shrink smaller than, the default value is <span class="number">233</span>.</span><br><span class="line">  <span class="number">328</span> | rcount      | <span class="number">0</span>x0000000000000000 | suspend count </span><br><span class="line">  <span class="number">336</span> | reds        | <span class="number">0</span>x0000000000002270 | keep track <span class="keyword">of</span> the total number <span class="keyword">of</span> reductions a process has done up until it was last suspended  </span><br><span class="line">   <span class="number">16</span> | tracer      | <span class="number">0</span>xfffffffffffffffb |                    |</span><br><span class="line">   <span class="number">24</span> | trace_fla.. | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">  <span class="number">344</span> | group_lea.. | <span class="number">0</span>x0000019800000333 |                    |</span><br><span class="line">  <span class="number">352</span> | flags       | <span class="number">0</span>x0000000000002000 |Trap exit, etc (no trace flags anymore)                    </span><br><span class="line">  <span class="number">360</span> | fvalue      | <span class="number">0</span>xfffffffffffffffb |Exit &amp; Throw value (failure reason)</span><br><span class="line">  <span class="number">368</span> | freason     | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">  <span class="number">320</span> | fcalls      | <span class="number">0</span>x00000000000005a2 | keeps the number <span class="keyword">of</span> reductions left to execute   </span><br><span class="line">  <span class="number">384</span> | next        | <span class="number">0</span>x0000000000000000 |next ready(runnable) process  in the ready queue <span class="keyword">of</span> scheduler    </span><br><span class="line">   <span class="number">48</span> | reg         | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">   <span class="number">56</span> | nlinks      | <span class="number">0</span>x00007f7f3cbc0750 |                    |</span><br><span class="line">  <span class="number">616</span> | mbuf        | <span class="number">0</span>x0000000000000000 |a memory area outside <span class="keyword">of</span> a process heap where other processes can safely write data                    </span><br><span class="line">  <span class="number">640</span> | mbuf_sz     | <span class="number">0</span>x0000000000000000 |Total size <span class="keyword">of</span> heap fragments <span class="keyword">and</span> message fragments</span><br><span class="line">  <span class="number">464</span> | dictionary  | <span class="number">0</span>x0000000000000000 | Process Dictionary                   </span><br><span class="line">  <span class="number">472</span> | seq..clock  | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">  <span class="number">480</span> | seq..astcnt | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">  <span class="number">488</span> | seq..token  | <span class="number">0</span>xfffffffffffffffb |                    |</span><br><span class="line">  <span class="number">496</span> | intial[<span class="number">0</span>]   | <span class="number">0</span>x000000000000320b |                    |</span><br><span class="line">  <span class="number">504</span> | intial[<span class="number">1</span>]   | <span class="number">0</span>x0000000000000c8b |                    |</span><br><span class="line">  <span class="number">512</span> | intial[<span class="number">2</span>]   | <span class="number">0</span>x0000000000000002 |                    |</span><br><span class="line">  <span class="number">520</span> | current     | <span class="number">0</span>x00007f7f3be87c20 | <span class="number">0</span>x000000000000ed8b |</span><br><span class="line">  <span class="number">296</span> | cp          | <span class="number">0</span>x00007f7f3d3a5100 | <span class="number">0</span>x0000000000440848 |</span><br><span class="line">  <span class="number">304</span> | i           | <span class="number">0</span>x00007f7f3be87c38 | <span class="number">0</span>x000000000044353a |</span><br><span class="line">  <span class="number">312</span> | catches     | <span class="number">0</span>x0000000000000001 |                    |</span><br><span class="line">  <span class="number">224</span> | arity       | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">  <span class="number">232</span> | arg_reg     | <span class="number">0</span>x00007f7f3cbc04f8 | <span class="number">0</span>x000000000000320b |</span><br><span class="line">  <span class="number">240</span> | max_arg_reg | <span class="number">0</span>x0000000000000006 |                    |</span><br><span class="line">  <span class="number">248</span> | def..reg[<span class="number">0</span>] | <span class="number">0</span>x000000000000320b |                    |</span><br><span class="line">  <span class="number">256</span> | def..reg[<span class="number">1</span>] | <span class="number">0</span>x0000000000000c8b |                    |</span><br><span class="line">  <span class="number">264</span> | def..reg[<span class="number">2</span>] | <span class="number">0</span>x00007f7f33ec9589 |                    |</span><br><span class="line">  <span class="number">272</span> | def..reg[<span class="number">3</span>] | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">  <span class="number">280</span> | def..reg[<span class="number">4</span>] | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">  <span class="number">288</span> | def..reg[<span class="number">5</span>] | <span class="number">0</span>x00000000000007d0 |                    |</span><br><span class="line">  <span class="number">136</span> | nsp         | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">  <span class="number">144</span> | nstack      | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">  <span class="number">152</span> | nstend      | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">  <span class="number">160</span> | ncallee     | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">   <span class="number">56</span> | ncsp        | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">   <span class="number">64</span> | narity      | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">---------------------------------------------------------------</span><br></pre></td></tr></tbody></table></figure>
<h3 id="邮箱以及消息传递"><a class="markdownIt-Anchor" href="#邮箱以及消息传递"></a> 邮箱以及消息传递</h3>
<p>Erlang所有的进程通过消息相互沟通。<br>
消息怎么发送呢？</p>
<ol>
<li><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_message.c#L1031">计算消息的大小</a></li>
<li><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_message.c#L1033">分配足够空间</a>（在发送者进程(<code>on_heap</code>)或者在不在发送者（<code>off_heap</code>）堆上）</li>
<li><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_message.c#L1040">复制消息</a> (从发送者的堆上复制到新分配的空间上)</li>
<li>分配一个<code>ErlMessage</code>结构用于包装消息</li>
<li>将消息(<code>ErlMessage</code>)<a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_message.c#L502">插入</a>  消息接收进程<a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_process.h#L1042">邮箱</a>（或者外部消息队列）</li>
</ol>
<blockquote>
<p>还有进程消息相关设置<code>message_queue_data</code> <code>on_heap</code> <code>off_heap</code>, 是否需要设置<code>message_queue_data</code> 要根据实际情况以及基准测试决定。<a href="https://github.com/erlang/otp/blob/master/erts/emulator/internal_doc/GarbageCollection.md#messages">More</a></p>
</blockquote>
<p>❗ on_heap</p>
<blockquote>
<p>在上面第五步时，发送消息的进程在发送消息时，会首先尝试获取接收消息进程的 <code>main lock</code> ，如果能获得了锁，就把消息写入 接受者的邮箱，否则就不会把消息写入<code>m_buf</code>中（也称为 <code>heap fragments</code>），在进程GC的时如果有大量的消息没有被处理，消息被移动到 <code>old heap</code>，这将会导致进程堆内存增长，并消耗更多的内存使用。</p>
</blockquote>
<p>❗ off_heap</p>
<blockquote>
<p>在上面第五步时，不会尝试去获取<code>main lock</code>，消息直接吸入 <code>m_buf</code> 。虽然这这回降低锁冲突，但是分配 <code>heap fragment</code>相比直接吸入进程堆消耗更高，会导致更高的内存使用率，可能会出现进程堆内存由很多空余，但是新的消息依然被写入 新的 <code>heap fragment</code></p>
</blockquote>
<p>❗ 在GC时处于邮箱（<code>internal message queue</code>）中的消息将会被检查，而处于"external" <code>message in queue</code>(<code>m_buf</code>)会被GC忽略。</p>
<h3 id="进程字典"><a class="markdownIt-Anchor" href="#进程字典"></a> 进程字典</h3>
<p>进程本地kv存储，最大优势是所有键值都存储在进程堆内存，效率相当的高而且由于在进程内部使用所以不会被复制。（消息或者ETS中的变量会复制）。 进程字典是由一个数组实现的，每个哈希值指向具有键值对的桶(<code>bucket</code>)。桶实际上Erlang中的<code>list</code>,每个元素是一个存放于进程堆上的元组({key, Value})。<br>
❗ 但是这并不是没有代价的，可能会导致进程GC或者当更新某个key对应的值时，会导致整个桶被重新分配。</p>
<h3 id="进程状态"><a class="markdownIt-Anchor" href="#进程状态"></a> 进程状态</h3>
<p><img src="/images/ProcessStateMachine.png" alt="进程状态机"></p>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<p><a href="https://happi.github.io/theBeamBook">The Beam Book</a></p>
]]></content>
      <categories>
        <category>Erlang</category>
      </categories>
      <tags>
        <tag>Erlang</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏服务器开发与运维</title>
    <url>/2022/12/21/gameserver/</url>
    <content><![CDATA[<p>服务器所有需要的技术</p>
<span id="more"></span>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<h2 id="开发"><a class="markdownIt-Anchor" href="#开发"></a> 开发</h2>
<h3 id="1-寻路系统"><a class="markdownIt-Anchor" href="#1-寻路系统"></a> 1. 寻路系统</h3>
<h2 id="运维"><a class="markdownIt-Anchor" href="#运维"></a> 运维</h2>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>游戏服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>数据驱动类技能</title>
    <url>/2022/04/07/GameSkill/</url>
    <content><![CDATA[<p><a href="https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools:zh-cn">Dota 2 Workshop Tools:zh-cn</a>‎ | <a href="https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools:zh-cn/Scripting:zh-cn">Scripting:zh-cn</a></p>
<p>几乎所有在DOTA2中的技能都是使用C++来编写的，当查看所有这些技能的时候，npc_abilities.txt包含了一些技能元数据的KV(Key-Values)文件，暴露出了一些技能的键值，这里包含了几乎所有的元数据，使用数据驱动类技能系统能够为DOTA2创造一些自定义技能，能够为他们赋予特殊的数值和特定的触发事件。</p>
<h2 id="一个简单的例子"><a class="markdownIt-Anchor" href="#一个简单的例子"></a> 一个简单的例子</h2>
<p>这是一个非常简单的技能，他是一个被动技能，给单位添加了一个粒子特效。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">"fx_test_ability"</span><br><span class="line">{</span><br><span class="line">    // General</span><br><span class="line">    //-------------------------------------------------------------------------------------------------------------</span><br><span class="line">    "BaseClass"             "ability_datadriven"</span><br><span class="line">    "AbilityBehavior"       "DOTA_ABILITY_BEHAVIOR_PASSIVE"</span><br><span class="line">    "AbilityTextureName"    "axe_battle_hunger"</span><br><span class="line"></span><br><span class="line">    // Modifiers</span><br><span class="line">    //-------------------------------------------------------------------------------------------------------------</span><br><span class="line">    "Modifiers"</span><br><span class="line">    {</span><br><span class="line">        "fx_test_modifier"</span><br><span class="line">        {</span><br><span class="line">            "Passive" "1"</span><br><span class="line">            "OnCreated"</span><br><span class="line">            {</span><br><span class="line">                "AttachEffect"</span><br><span class="line">                {</span><br><span class="line">                    "Target" "CASTER"</span><br><span class="line">                    "EffectName" "particles/econ/generic/generic_buff_1/generic_buff_1.vpcf"</span><br><span class="line">                    "EffectAttachType" "follow_overhead"</span><br><span class="line">                    "EffectLifeDurationScale" "1"</span><br><span class="line">                    "EffectColorA" "255 255 0"</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其中，基类(“BaseClass”),技能行为(“AbilityBehavior”)和技能图标名称(“AbilityTextureName”)在所有技能中都是类似的。</p>
<span id="more"></span>
<h3 id="范例分解"><a class="markdownIt-Anchor" href="#范例分解"></a> 范例分解</h3>
<ul>
<li><code>"BaseClass" (基类)</code>
<ul>
<li><code>"AbilityBehavior" (技能行为)</code></li>
<li><code>"ID"</code></li>
<li><code>"AbilityTextureName" (技能图标名称)</code></li>
</ul>
</li>
<li><code>"Modifiers"</code>
<ul>
<li><code>"Passive" (被动)</code></li>
<li><code>"OnCreated" (当创建时)</code></li>
</ul>
</li>
</ul>
<h2 id="技能行为"><a class="markdownIt-Anchor" href="#技能行为"></a> 技能行为</h2>
<p>“AbilityBehavior” (技能行为) 的全部类型，会使技能有不用的释放方式。你能够使用<code>|</code>来分割不同的常量，比如说 “DOTA_ABILITY_BEHAVIOR_HIDDEN | DOTA_ABILITY_BEHAVIOR_NO_TARGET” - 这些空格是很重要的！</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">DOTA_ABILITY_BEHAVIOR_HIDDEN               = 1 &lt;&lt; 0, //这个技能是单位所拥有的技能，但是不会在HUD上显示。</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_PASSIVE              = 1 &lt;&lt; 1, //这个技能是一个被动技能，不能被使用，但是会在HUD上显示。</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_NO_TARGET            = 1 &lt;&lt; 2, //不需要指定目标就能释放的技能，当按下技能按钮的时候，这个技能就会被释放。</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_UNIT_TARGET          = 1 &lt;&lt; 3, //技能需要指定一个目标来释放。</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_POINT                = 1 &lt;&lt; 4, //技能将会在鼠标指定的位置释放（如果鼠标指向了一个单位，会在单位所在的位置释放）。</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_AOE                  = 1 &lt;&lt; 5, //这个技能将会显示技能释放的范围，有点像DOTA_ABILITY_BEHAVIOR_POINT类的技能，但是会显示一个范围。</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_NOT_LEARNABLE        = 1 &lt;&lt; 6, //这个技能将能被释放，或者拥有对应的释放机制，但是不能被学习。（一般是用在类似炸弹人的引爆炸弹技能）。</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_CHANNELLED           = 1 &lt;&lt; 7, //持续性施法技能，如果施法者移动或者被沉默，这个技能将会被中断。</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_ITEM                 = 1 &lt;&lt; 8, //这个技能绑定了一个物品。</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_TOGGLE               = 1 &lt;&lt; 9, //切换类技能。</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_DIRECTIONAL          = 1 &lt;&lt; 10, //这个技能是一个从英雄出发的方向性技能，比如米拉娜的月之神剑或者屠夫的肉钩。</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_IMMEDIATE            = 1 &lt;&lt; 11, //这个技能将会被立即释放，不会进入操作序列。</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_AUTOCAST             = 1 &lt;&lt; 12, //这个技能可以被自动释放。</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_NOASSIST             = 1 &lt;&lt; 13, //这个技能将不会有辅助网格。</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_AURA                 = 1 &lt;&lt; 14, //这个技能是一个光环技能，Not really used other than to tag the ability as such.</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_ATTACK               = 1 &lt;&lt; 15, //这个技能是一个法球技能，不能对魔法免疫目标生效，</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_DONT_RESUME_MOVEMENT = 1 &lt;&lt; 16, //这个技能在释放完成之后不会继续之前的移动操作，只能和无目标或者立即释放类技能配合使用。</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_ROOT_DISABLES        = 1 &lt;&lt; 17, //这个技能在单位被定身的时候无法使用。</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_UNRESTRICTED         = 1 &lt;&lt; 18, //这个技能在释放指令被限制的时候也能被使用。</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_IGNORE_PSEUDO_QUEUE  = 1 &lt;&lt; 19, //这个技能在被眩晕，施法和被强制攻击的时候也能使用，只能和自动释放类DOTA_ABILITY_BEHAVIOR_AUTOCAST配合使用。</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_IGNORE_CHANNEL       = 1 &lt;&lt; 20, //这个技能即使施法被中断也能继续释放。</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_DONT_CANCEL_MOVEMENT = 1 &lt;&lt; 21, //Doesn't cause certain modifiers to end, 目前未知，只在信使的速度爆发有见到。</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_DONT_ALERT_TARGET    = 1 &lt;&lt; 22, //这个技能在指定敌人释放的时候将不会惊醒他们。</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_DONT_RESUME_ATTACK   = 1 &lt;&lt; 23, //这个技能在释放完成之后，将不会恢复对之前目标的自动攻击，只能配合无目标，非立即释放类和指定单位目标类技能使用。</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_NORMAL_WHEN_STOLEN   = 1 &lt;&lt; 24, //这个技能在被偷取之后，依然使用之前的施法前摇。</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_IGNORE_BACKSWING     = 1 &lt;&lt; 25, //这个技能将会无视施法后摇。</span><br><span class="line">DOTA_ABILITY_BEHAVIOR_RUNE_TARGET          = 1 &lt;&lt; 26, //这个技能能以神符为目标。</span><br></pre></td></tr></tbody></table></figure>
<h2 id="技能触发事件和操作"><a class="markdownIt-Anchor" href="#技能触发事件和操作"></a> 技能触发事件和操作</h2>
<p>技能可以有各种游戏中的事件，这些事件可以触发操作。</p>
<p>一个关于事件和操作的范例。在这个范例中，当你开始释放技能，就会在施法者上播放音效。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">"OnSpellStart"      // 事件</span><br><span class="line">{</span><br><span class="line">    "FireSound"     // 操作</span><br><span class="line">    {</span><br><span class="line">        "EffectName"    "SoundEventName"</span><br><span class="line">        "Target"        "CASTER"</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="事件"><a class="markdownIt-Anchor" href="#事件"></a> 事件</h3>
<p>引擎为技能提供了一系列触发事件，这些事件将能够在技能中触发：</p>
<table>
<thead>
<tr>
<th style="text-align:center">触发事件名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">OnChannelFinish</td>
<td style="text-align:center">当持续性施法完成</td>
</tr>
<tr>
<td style="text-align:center">OnChannelInterrupted</td>
<td style="text-align:center">当持续性施法被中断</td>
</tr>
<tr>
<td style="text-align:center">OnChannelSucceeded</td>
<td style="text-align:center">当持续性施法成功</td>
</tr>
<tr>
<td style="text-align:center">OnOwnerDied</td>
<td style="text-align:center">当拥有者死亡</td>
</tr>
<tr>
<td style="text-align:center">OnOwnerSpawned</td>
<td style="text-align:center">当拥有者出生</td>
</tr>
<tr>
<td style="text-align:center">OnProjectileFinish</td>
<td style="text-align:center">当弹道粒子特效结束</td>
</tr>
<tr>
<td style="text-align:center">OnProjectileHitUnit</td>
<td style="text-align:center">当弹道粒子特效命中单位</td>
</tr>
<tr>
<td style="text-align:center">OnSpellStart</td>
<td style="text-align:center">当技能施法开始</td>
</tr>
<tr>
<td style="text-align:center">OnToggleOff</td>
<td style="text-align:center">当切换为关闭状态</td>
</tr>
<tr>
<td style="text-align:center">OnToggleOn</td>
<td style="text-align:center">当切换为开启状态</td>
</tr>
<tr>
<td style="text-align:center">OnUpgrade</td>
<td style="text-align:center">当升级</td>
</tr>
</tbody>
</table>
<h3 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h3>
<p>以下是你在技能中能够使用操作中的一些Key：</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作名称</th>
<th style="text-align:center">操作可用参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AddAbility</td>
<td style="text-align:center">Target, AbilityName</td>
</tr>
<tr>
<td style="text-align:center">添加技能</td>
<td style="text-align:center">目标，技能名称</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">ActOnTargets</td>
<td style="text-align:center">Target, Action</td>
</tr>
<tr>
<td style="text-align:center">使目标模型做出某个动作</td>
<td style="text-align:center">目标，动作名称</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">ApplyModifier</td>
<td style="text-align:center">Target, ModifierName</td>
</tr>
<tr>
<td style="text-align:center">应用Modifier</td>
<td style="text-align:center">目标，Modifier名称</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">AttachEffect</td>
<td style="text-align:center">EffectName, EffectAttachType, Target, ControlPoints, EffectColorA, EffectColorB, EffectAlphaScale</td>
</tr>
<tr>
<td style="text-align:center">附着点特效</td>
<td style="text-align:center">特效名称，特效附着点类型，目标，控制点，特效颜色A，特效颜色B，特效不透明度比例</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Blink</td>
<td style="text-align:center">Target</td>
</tr>
<tr>
<td style="text-align:center">闪烁</td>
<td style="text-align:center">目标</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CleaveAttack</td>
<td style="text-align:center">CleavePercent, CleaveRadius</td>
</tr>
<tr>
<td style="text-align:center">范围攻击</td>
<td style="text-align:center">分裂伤害，分裂范围</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CreateThinker</td>
<td style="text-align:center">Target, ModifierName</td>
</tr>
<tr>
<td style="text-align:center">创建Thinker(定时器)</td>
<td style="text-align:center">目标，Modifier名称</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Damage</td>
<td style="text-align:center">Target, Type, MinDamage/MaxDamage, Damage, CurrentHealthPercentBasedDamage, MaxHealthPercentBasedDamage</td>
</tr>
<tr>
<td style="text-align:center">伤害</td>
<td style="text-align:center">目标，伤害类型，最小/最大伤害值，伤害值，基于当前生命百分比伤害，基于最大生命百分比伤害</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">DelayedAction</td>
<td style="text-align:center">Delay, Action</td>
</tr>
<tr>
<td style="text-align:center">延迟操作</td>
<td style="text-align:center">延迟时间，操作</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">DestroyTrees</td>
<td style="text-align:center">Target, Radius</td>
</tr>
<tr>
<td style="text-align:center">摧毁树木</td>
<td style="text-align:center">目标，范围</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">FireEffect</td>
<td style="text-align:center">EffectName, EffectAttachType, Target, ControlPoints, TargetPoint, EffectRadius, EffectDurationScale, EffectLifeDurationScale, EffectColorA, EffectColorB</td>
</tr>
<tr>
<td style="text-align:center">播放特效</td>
<td style="text-align:center">特效名称，特效附着点类型，目标，控制点，目标点，特效范围，特效播放时间比例，特效存活时间比例，特效颜色A，特效颜色B</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">FireSound</td>
<td style="text-align:center">EffectName, Target</td>
</tr>
<tr>
<td style="text-align:center">播放声音</td>
<td style="text-align:center">音效名称，目标</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Heal</td>
<td style="text-align:center">HealAmount, Target</td>
</tr>
<tr>
<td style="text-align:center">治愈</td>
<td style="text-align:center">治疗量，目标</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Knockback</td>
<td style="text-align:center">Target, Center, Duration, Distance, Height, IsFixedDistance, ShouldStun</td>
</tr>
<tr>
<td style="text-align:center">击退</td>
<td style="text-align:center">目标，中心，持续时间，距离，高度，固定距离，是否眩晕</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">LevelUpAbility</td>
<td style="text-align:center">Target, AbilityName</td>
</tr>
<tr>
<td style="text-align:center">升级技能</td>
<td style="text-align:center">目标，技能名称</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Lifesteal</td>
<td style="text-align:center">Target, LifestealPercent</td>
</tr>
<tr>
<td style="text-align:center">吸血</td>
<td style="text-align:center">目标，吸血百分比</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">LinearProjectile</td>
<td style="text-align:center">Target, EffectName, MoveSpeed, StartRadius, EndRadius, FixedDistance, StartPosition, TargetTeams, TargetTypes, TargetFlags, HasFrontalCone, ProvidesVision, VisionRadius</td>
</tr>
<tr>
<td style="text-align:center">线性投射物</td>
<td style="text-align:center">目标，特效名称，移动速度，开始范围，结束范围，固定距离，开始位置，目标队伍，目标类型，目标状态，HasFrontalCone，提供视野，视野范围</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Random</td>
<td style="text-align:center">Chance, PseudoRandom, OnSuccess, OnFailure</td>
</tr>
<tr>
<td style="text-align:center">几率</td>
<td style="text-align:center">概率，伪随机，成功时，失败时</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RemoveAbility</td>
<td style="text-align:center">Target, AbilityName</td>
</tr>
<tr>
<td style="text-align:center">移除技能</td>
<td style="text-align:center">目标，技能名称</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RemoveModifier</td>
<td style="text-align:center">Target, ModifierName</td>
</tr>
<tr>
<td style="text-align:center">移除Modifier</td>
<td style="text-align:center">目标，Modifier名称</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">RunScript</td>
<td style="text-align:center">Target, ScriptFile, Function</td>
</tr>
<tr>
<td style="text-align:center">运行脚本</td>
<td style="text-align:center">目标，脚本文件，运行函数</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">SpawnUnit</td>
<td style="text-align:center">UnitName, UnitCount, UnitLimit, SpawnRadius, Duration, Target, GrantsGold, GrantsXP</td>
</tr>
<tr>
<td style="text-align:center">生产单位</td>
<td style="text-align:center">单位名称，单位数量，单位上限，生产范围，持续时间，目标，死亡金钱量，死亡经验量</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Stun</td>
<td style="text-align:center">Target, Duration</td>
</tr>
<tr>
<td style="text-align:center">击晕</td>
<td style="text-align:center">目标，持续时间</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">TrackingProjectile</td>
<td style="text-align:center">Target, EffectName, Dodgeable, ProvidesVision, VisionRadius, MoveSpeed, SourceAttachment</td>
</tr>
<tr>
<td style="text-align:center">跟踪投射物</td>
<td style="text-align:center">目标，特效名称，是否可闪避，提供视野，视野范围，移动速度，起源附着点</td>
</tr>
</tbody>
</table>
<p><strong><img src="https://developer.valvesoftware.com/w/images/c/cc/Note.png" alt="img"> 注意：</strong><code>AddAbility</code> （增加技能）将会给单位添加一个0级的技能。 <code>RemoveAbility</code> （移除技能）将会移除对应技能（哪怕它已经升级了），更复杂的技能管理，应当通过程序来制作。</p>
<h2 id="操作目标"><a class="markdownIt-Anchor" href="#操作目标"></a> 操作目标</h2>
<p>在操作之前，首先应该选中目标(Target)。以下有几种选择方式。</p>
<p>**<img src="https://developer.valvesoftware.com/w/images/c/cc/Note.png" alt="img"> 注意：**在几乎所有操作中，都需要选中目标。这非常重要，直接影响到你的技能效果。</p>
<h3 id="单体目标"><a class="markdownIt-Anchor" href="#单体目标"></a> 单体目标</h3>
<p>小范例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">"Target"  "CASTER"</span><br></pre></td></tr></tbody></table></figure>
<p>单体目标有以下这些值：</p>
<blockquote>
<p>|   名称   |  描述  |<br>
| :------: | :----: |<br>
|  CASTER  | 施法者 |<br>
|  TARGET  |  目标  |<br>
|  POINT  |   点   |<br>
| ATTACKER | 攻击者 |<br>
|   UNIT   |  单位  |</p>
</blockquote>
<p>在页面最上例子中，就是用<code>"Target(目标)" "CASTER(施法者)"</code>，在施法者身上制造些特效。</p>
<p><strong><img src="https://developer.valvesoftware.com/w/images/c/cc/Note.png" alt="Note.png"> Note:</strong> 在不同的操作中，这些字段提供的是不同的目标，你需要自己实际使用一下才能明白。</p>
<h3 id="多个目标"><a class="markdownIt-Anchor" href="#多个目标"></a> 多个目标</h3>
<p>小范例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">"Target"</span><br><span class="line">{</span><br><span class="line">    "Center"    "POINT"</span><br><span class="line">    "Teams"     "DOTA_UNIT_TARGET_TEAM_ENEMY"</span><br><span class="line">    "Radius"    "300"</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>想要在某个区域里选中多个目标，就需要在 Target代码块 中填入下面的参数：</p>
<ul>
<li><code>Center</code> - 以目标为搜索范围的中心</li>
</ul>
<blockquote>
<p>|  中心目标  |  描述  |<br>
| :--------: | :----: |<br>
|   CASTER   | 施法者 |<br>
|   TARGET   |  目标  |<br>
|   POINT   |   点   |<br>
|  ATTACKER  | 攻击者 |<br>
|    UNIT    |  单位  |<br>
| PROJECTILE | 抛射物 |</p>
</blockquote>
<ul>
<li><code>Radius </code>- 搜索目标的范围</li>
<li><code>Teams</code> - 根据队伍筛选目标（一样可以用 | 来指定多种类型）</li>
</ul>
<blockquote>
<p>|            目标队伍            |   描述   |<br>
| :----------------------------: | :------: |<br>
|   DOTA_UNIT_TARGET_TEAM_BOTH   | 双方队伍 |<br>
|  DOTA_UNIT_TARGET_TEAM_CUSTOM  | 普通队伍 |<br>
|  DOTA_UNIT_TARGET_TEAM_ENEMY  | 敌方队伍 |<br>
| DOTA_UNIT_TARGET_TEAM_FRIENDLY | 友方队伍 |<br>
|   DOTA_UNIT_TARGET_TEAM_NONE   |    无    |</p>
</blockquote>
<ul>
<li><code>Types - 指定的类型，ExcludeTypes - 排除对应的类型</code> （一样可以用 | 来指定多种类型）</li>
</ul>
<blockquote>
<p>|            类型            | 描述 |<br>
| :-------------------------: | :–: |<br>
|    DOTA_UNIT_TARGET_ALL    | 所有 |<br>
|   DOTA_UNIT_TARGET_BASIC   | 基本 |<br>
|  DOTA_UNIT_TARGET_BUILDING  | 建筑 |<br>
|  DOTA_UNIT_TARGET_COURIER  | 信使 |<br>
|   DOTA_UNIT_TARGET_CREEP   | 野怪 |<br>
|   DOTA_UNIT_TARGET_CUSTOM   | 普通 |<br>
|    DOTA_UNIT_TARGET_HERO    | 英雄 |<br>
| DOTA_UNIT_TARGET_MECHANICAL | 机械 |<br>
|    DOTA_UNIT_TARGET_NONE    |  无  |<br>
|   DOTA_UNIT_TARGET_OTHER   | 其他 |<br>
|    DOTA_UNIT_TARGET_TREE    | 树木 |</p>
</blockquote>
<ul>
<li><code>Flags - 指定目标的状态，ExcludeFlags - 排除对应状态的目标</code> （一样可以用 | 来指定多种类型）</li>
</ul>
<blockquote>
<p>|                     名称                     |          描述          |<br>
| :-------------------------------------------: | :--------------------: |<br>
|   DOTA_UNIT_TARGET_FLAG_CHECK_DISABLE_HELP   | 检测玩家"禁用帮助"选项 |<br>
|          DOTA_UNIT_TARGET_FLAG_DEAD          |         已死亡         |<br>
|       DOTA_UNIT_TARGET_FLAG_FOW_VISIBLE       |       <em>暂无说明</em>       |<br>
|      DOTA_UNIT_TARGET_FLAG_INVULNERABLE      |          无敌          |<br>
|  DOTA_UNIT_TARGET_FLAG_MAGIC_IMMUNE_ENEMIES  |     魔法免疫的敌人     |<br>
|        DOTA_UNIT_TARGET_FLAG_MANA_ONLY        |       <em>暂无说明</em>       |<br>
|       DOTA_UNIT_TARGET_FLAG_MELEE_ONLY       |       <em>暂无说明</em>       |<br>
|        DOTA_UNIT_TARGET_FLAG_NO_INVIS        |       不是隐形的       |<br>
|          DOTA_UNIT_TARGET_FLAG_NONE          |           无           |<br>
|      DOTA_UNIT_TARGET_FLAG_NOT_ANCIENTS      |        不是远古        |<br>
|    DOTA_UNIT_TARGET_FLAG_NOT_ATTACK_IMMUNE    |      不是攻击免疫      |<br>
|     DOTA_UNIT_TARGET_FLAG_NOT_CREEP_HERO     |        不是野怪        |<br>
|      DOTA_UNIT_TARGET_FLAG_NOT_DOMINATED      |       不可控制的       |<br>
|      DOTA_UNIT_TARGET_FLAG_NOT_ILLUSIONS      |        不是幻象        |<br>
| DOTA_UNIT_TARGET_FLAG_NOT_MAGIC_IMMUNE_ALLIES |   不是魔法免疫的盟友   |<br>
|     DOTA_UNIT_TARGET_FLAG_NOT_NIGHTMARED     |       非被催眠的       |<br>
|      DOTA_UNIT_TARGET_FLAG_NOT_SUMMONED      |        非召唤的        |<br>
|      DOTA_UNIT_TARGET_FLAG_OUT_OF_WORLD      |     被放逐出世界的     |<br>
|    DOTA_UNIT_TARGET_FLAG_PLAYER_CONTROLLED    |       玩家控制的       |<br>
|       DOTA_UNIT_TARGET_FLAG_RANGED_ONLY       |       范围唯一的       |</p>
</blockquote>
<ul>
<li><code>MaxTargets</code> - 最多目标数量</li>
<li><code>Random</code> - 在指定了最多目标数量之后，是否额外随机多选择一个单位。</li>
<li><code>ScriptSelectPoints</code> - <em>暂无说明</em></li>
</ul>
<p>**<img src="https://developer.valvesoftware.com/w/images/c/cc/Note.png" alt="img"> 注意：**将<code>Random</code> 和 <code>MaxTargets</code> 共同使用，将<code>Random</code> 设置为0将会使操作只影响目标区域内<code>MaxTargets</code>或者更少的单位。</p>
<h2 id="modifiers"><a class="markdownIt-Anchor" href="#modifiers"></a> Modifiers</h2>
<p>是只有data-driven类技能才能使用的，这个区域定义了一系列的Modifiers（一般可以认为是Buff或者DeBuff），每个Modifier通过在其中定义的KV(KeyValues)来定义。 参数有以下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">可用参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Attributes</td>
<td style="text-align:center">MODIFIER_ATTRIBUTE_IGNORE_INVULNERABLE, MODIFIER_ATTRIBUTE_MULTIPLE, MODIFIER_ATTRIBUTE_NONE, MODIFIER_ATTRIBUTE_PERMANENT</td>
</tr>
<tr>
<td style="text-align:center">属性</td>
<td style="text-align:center">忽视无敌，可叠加，无，正常</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Duration</td>
<td style="text-align:center">FloatValue</td>
</tr>
<tr>
<td style="text-align:center">持续时间</td>
<td style="text-align:center">浮点值</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">EffectAttachType</td>
<td style="text-align:center">follow_origin, follow_overhead, follow_chest, follow_head, start_at_customorigin, world_origin</td>
</tr>
<tr>
<td style="text-align:center">特效附着点类型</td>
<td style="text-align:center">原点，头顶，胸膛，头部，自定义原点，世界原点</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">EffectName</td>
<td style="text-align:center">StringValue</td>
</tr>
<tr>
<td style="text-align:center">特效名称</td>
<td style="text-align:center">字符串(路径+特效名)</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">IsBuff</td>
<td style="text-align:center">BooleanValue</td>
</tr>
<tr>
<td style="text-align:center">是否增益魔法</td>
<td style="text-align:center">布尔值（1为增益魔法）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">IsDebuff</td>
<td style="text-align:center">BooleanValue</td>
</tr>
<tr>
<td style="text-align:center">是否减益魔法</td>
<td style="text-align:center">布尔值（1为减益魔法）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">IsHidden</td>
<td style="text-align:center">BooleanValue</td>
</tr>
<tr>
<td style="text-align:center">是否隐藏</td>
<td style="text-align:center">布尔值（1为隐藏）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">IsPurgable</td>
<td style="text-align:center">BooleanValue</td>
</tr>
<tr>
<td style="text-align:center">能否被驱散</td>
<td style="text-align:center">布尔值（1为可被驱散）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">OverrideAnimation</td>
<td style="text-align:center">ACT_DOTA_ATTACK, ACT_DOTA_CAST_ABILITY_1 (2, 3, 4, 5, 6), ACT_DOTA_DISABLED, ACT_DOTA_SPAWN, ACT_DOTA_TELEPORT, ACT_DOTA_VICTORY</td>
</tr>
<tr>
<td style="text-align:center">覆盖模型动作</td>
<td style="text-align:center">攻击动作，技能释放动作(1~6)，受伤动作，出生动作，回程动作，胜利动作</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Passive</td>
<td style="text-align:center">BooleanValue</td>
</tr>
<tr>
<td style="text-align:center">被动</td>
<td style="text-align:center">布尔值（1为被动技能，会自动添加该Modifiers）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">TextureName</td>
<td style="text-align:center">StringValue</td>
</tr>
<tr>
<td style="text-align:center">图标名称</td>
<td style="text-align:center">字符串</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">ThinkInterval</td>
<td style="text-align:center">FloatValue</td>
</tr>
<tr>
<td style="text-align:center">Think间隔</td>
<td style="text-align:center">浮点值</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="modifier-属性"><a class="markdownIt-Anchor" href="#modifier-属性"></a> Modifier 属性</h2>
<p>Modifier属性能够改变对应Modifier影响的单位的游戏相关数值，以下示例定义的是一个降低目标攻击和移动速度的modifier（写在技能的Modifiers区域内），对于数值，你可以直接在区域直接写入数值，也可以使用 %name 来引用 AbilitySpecial区域内定义的数值，使用%name的好处是你能够针对不同的技能等级定义不同的数值，也可以在技能的说明中直接引用这个数值，在本示例中，Modifier的持续时间（“Duration”）引用了AbilitySpecial中的数值，减速的数值是直接写的数字。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">"creature_slithereen_crush_slow"</span><br><span class="line">{</span><br><span class="line">    "Duration"      "%slow_duration"</span><br><span class="line">    "Properties"</span><br><span class="line">    {</span><br><span class="line">        "MODIFIER_PROPERTY_MOVESPEED_BONUS_PERCENTAGE"      "-20"</span><br><span class="line">        "MODIFIER_PROPERTY_ATTACKSPEED_BONUS_CONSTANT"      "-20"</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="modifier-属性列表"><a class="markdownIt-Anchor" href="#modifier-属性列表"></a> Modifier 属性列表</h3>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_ABSOLUTE_NO_DAMAGE_MAGICAL</td>
<td style="text-align:center">所有魔法攻击无效</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_ABSOLUTE_NO_DAMAGE_PHYSICAL</td>
<td style="text-align:center">所有物理攻击无效</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_ABSOLUTE_NO_DAMAGE_PURE</td>
<td style="text-align:center">所有神圣伤害无效</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_ABSORB_SPELL</td>
<td style="text-align:center">偷取法术？</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_ATTACK_RANGE_BONUS</td>
<td style="text-align:center">修改攻击范围</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_ATTACK_RANGE_BONUS_UNIQUE</td>
<td style="text-align:center">攻击距离增益（不叠加）</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_ATTACKSPEED_BONUS_CONSTANT</td>
<td style="text-align:center">修改攻击速度</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_ATTACKSPEED_BONUS_CONSTANT_POWER_TREADS</td>
<td style="text-align:center"><em>暂无说明</em></td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_ATTACKSPEED_BONUS_CONSTANT_SECONDARY</td>
<td style="text-align:center"><em>暂无说明</em></td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_AVOID_CONSTANT</td>
<td style="text-align:center">虚空假面的闪避？</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_AVOID_SPELL</td>
<td style="text-align:center">虚空假面的法术闪避？</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_BASEATTACK_BONUSDAMAGE</td>
<td style="text-align:center">修改基础攻击力</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_BASE_ATTACK_TIME_CONSTANT</td>
<td style="text-align:center">设定基础攻击间隔</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_BASEDAMAGEOUTGOING_PERCENTAGE</td>
<td style="text-align:center">修改基础攻击伤害</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_BASE_MANA_REGEN</td>
<td style="text-align:center">修改基础魔法回复数值，对百分比回魔有影响</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_BONUS_DAY_VISION</td>
<td style="text-align:center">修改白天的视野距离</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_BONUS_NIGHT_VISION</td>
<td style="text-align:center">修改夜间的视野距离</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_BONUS_VISION_PERCENTAGE</td>
<td style="text-align:center">按百分比修改视野距离</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_CAST_RANGE_BONUS</td>
<td style="text-align:center">施法距离增益</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_CHANGE_ABILITY_VALUE</td>
<td style="text-align:center">改变技能数值</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_COOLDOWN_PERCENTAGE_STACKING</td>
<td style="text-align:center">冷却时间百分比堆叠</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_COOLDOWN_REDUCTION_CONSTANT</td>
<td style="text-align:center">减少冷却时间</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_DAMAGEOUTGOING_PERCENTAGE</td>
<td style="text-align:center">按百分比修改攻击力，负数降低攻击，正数提高攻击</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_DAMAGEOUTGOING_PERCENTAGE_ILLUSION</td>
<td style="text-align:center">降低幻象攻击力比例</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_DEATHGOLDCOST</td>
<td style="text-align:center">修改死亡损失的金钱</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_DISABLE_AUTOATTACK</td>
<td style="text-align:center">禁止自动攻击</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_DISABLE_HEALING</td>
<td style="text-align:center">禁止生命回复(1为禁止)</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_DISABLE_TURNING</td>
<td style="text-align:center">禁止转身</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_EVASION_CONSTANT</td>
<td style="text-align:center">闪避</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_EXTRA_HEALTH_BONUS</td>
<td style="text-align:center"><em>无效</em>额外生命值加成</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_EXTRA_MANA_BONUS</td>
<td style="text-align:center"><em>无效</em>额外魔法值加成</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_EXTRA_STRENGTH_BONUS</td>
<td style="text-align:center"><em>无效</em>额外力量加成</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_FORCE_DRAW_MINIMAP</td>
<td style="text-align:center"><em>暂无说明</em></td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_HEALTH_BONUS</td>
<td style="text-align:center">修改目前血量</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_HEALTH_REGEN_CONSTANT</td>
<td style="text-align:center">固定的生命回复数值</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_HEALTH_REGEN_PERCENTAGE</td>
<td style="text-align:center">根据装备带来的最大血量所产生的血量回复数值</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_IGNORE_CAST_ANGLE</td>
<td style="text-align:center">忽略施法角度</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_INCOMING_DAMAGE_PERCENTAGE</td>
<td style="text-align:center">按百分比修改受到的所有伤害，负数降低伤害，正数加深伤害</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_INCOMING_PHYSICAL_DAMAGE_CONSTANT</td>
<td style="text-align:center">所受物理伤害数值（数值物理伤害减免/增加）</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_INCOMING_PHYSICAL_DAMAGE_PERCENTAGE</td>
<td style="text-align:center">按百分比修改受到的物理伤害，负数降低伤害，正数加深伤害</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_INCOMING_SPELL_DAMAGE_CONSTANT</td>
<td style="text-align:center">按百分比修改受到的技能伤害，负数降低伤害，正数加深伤害</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_INVISIBILITY_LEVEL</td>
<td style="text-align:center">隐身等级？</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_IS_ILLUSION</td>
<td style="text-align:center">是否为某个单位的幻象</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_IS_SCEPTER</td>
<td style="text-align:center">是否携带蓝杖？</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_LIFETIME_FRACTION</td>
<td style="text-align:center"><em>暂无说明</em></td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_MAGICAL_RESISTANCE_BONUS</td>
<td style="text-align:center">魔法抗性，对神圣伤害无效，可以累加</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_MAGICAL_RESISTANCE_DECREPIFY_UNIQUE</td>
<td style="text-align:center">骨法的衰老，影响魔法抗性，不可累加</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_MAGICAL_RESISTANCE_ITEM_UNIQUE</td>
<td style="text-align:center">魔法抗性，对神圣伤害无效，不可以累加</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_MAGICDAMAGEOUTGOING_PERCENTAGE</td>
<td style="text-align:center">魔法输出百分比（百分比法伤增益/减益）</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_MANA_BONUS</td>
<td style="text-align:center">修改目前魔法量</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_MANA_REGEN_CONSTANT</td>
<td style="text-align:center">修改基础魔法回复数值，对百分比回魔没有影响</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_MANA_REGEN_CONSTANT_UNIQUE</td>
<td style="text-align:center">修改基础魔法回复数值，对百分比回魔没有影响，且 不可累积</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_MANA_REGEN_PERCENTAGE</td>
<td style="text-align:center">修改基础魔法回复数值</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_MANA_REGEN_TOTAL_PERCENTAGE</td>
<td style="text-align:center">修改所有魔法回复数值</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_MAX_ATTACK_RANGE</td>
<td style="text-align:center">最大攻击距离增益</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_MIN_HEALTH</td>
<td style="text-align:center">血量在设定值以下是不能杀死（斧王的斩杀依然有效）</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_MISS_PERCENTAGE</td>
<td style="text-align:center">增加miss的几率</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_MODEL_CHANGE</td>
<td style="text-align:center">设定模型</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_MODEL_SCALE</td>
<td style="text-align:center">设定模型大小</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_MOVESPEED_ABSOLUTE</td>
<td style="text-align:center">设置移动速度</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_MOVESPEED_BASE_OVERRIDE</td>
<td style="text-align:center">设定基础移动速度</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_MOVESPEED_BONUS_CONSTANT</td>
<td style="text-align:center">增加移动速度数值</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_MOVESPEED_BONUS_PERCENTAGE</td>
<td style="text-align:center">百分比增加移动速度，自身不叠加</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_MOVESPEED_BONUS_PERCENTAGE_UNIQUE</td>
<td style="text-align:center">独立百分比增加移动速度，不叠加</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_MOVESPEED_BONUS_UNIQUE</td>
<td style="text-align:center">增加移动速度数值，不叠加，物品版本</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_MOVESPEED_LIMIT</td>
<td style="text-align:center">限制移动速度</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_MOVESPEED_MAX</td>
<td style="text-align:center">设置最大移动速度</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_NEGATIVE_EVASION_CONSTANT</td>
<td style="text-align:center">降低闪避概率</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_OVERRIDE_ANIMATION</td>
<td style="text-align:center">强制播放模型动作</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_OVERRIDE_ANIMATION_RATE</td>
<td style="text-align:center">设置播放模型动作快慢</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_OVERRIDE_ANIMATION_WEIGHT</td>
<td style="text-align:center">强制播放模型动作_重？</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_OVERRIDE_ATTACK_MAGICAL</td>
<td style="text-align:center">魔法攻击</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_PERSISTENT_INVISIBILITY</td>
<td style="text-align:center">永久性隐身</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_PHYSICAL_ARMOR_BONUS</td>
<td style="text-align:center">增加护甲</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_PHYSICAL_ARMOR_BONUS_ILLUSIONS</td>
<td style="text-align:center">增加幻象的护甲</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_PHYSICAL_ARMOR_BONUS_UNIQUE</td>
<td style="text-align:center">增加护甲，不可叠加</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_PHYSICAL_ARMOR_BONUS_UNIQUE_ACTIVE</td>
<td style="text-align:center">改变圆盾减伤的效果？</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_PHYSICAL_CONSTANT_BLOCK</td>
<td style="text-align:center">数值减免伤害？</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_POST_ATTACK</td>
<td style="text-align:center">增加攻击力？</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_PREATTACK_BONUS_DAMAGE</td>
<td style="text-align:center">修改附加攻击力</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_PREATTACK_BONUS_DAMAGE_POST_CRIT</td>
<td style="text-align:center">以增加伤害的方式修改伤害值，不计入暴击计算</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_PREATTACK_CRITICALSTRIKE</td>
<td style="text-align:center">致命一击</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_PROCATTACK_BONUS_DAMAGE_COMPOSITE</td>
<td style="text-align:center">修改在普通攻击后计算的神圣伤害</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_PROCATTACK_BONUS_DAMAGE_MAGICAL</td>
<td style="text-align:center">修改在普通攻击后计算的魔法伤害</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_PROCATTACK_BONUS_DAMAGE_PHYSICAL</td>
<td style="text-align:center">修改在普通攻击后计算的物理伤害</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_PROCATTACK_BONUS_DAMAGE_PURE</td>
<td style="text-align:center">修改在普通攻击后计算的神圣伤害</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_PROCATTACK_FEEDBACK</td>
<td style="text-align:center">法力燃烧？</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_PROVIDES_FOW_POSITION</td>
<td style="text-align:center"><em>暂无说明</em></td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_REINCARNATION</td>
<td style="text-align:center">不朽之守护或者是骷髅王的大招？</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_RESPAWNTIME</td>
<td style="text-align:center">修改重生时间</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_RESPAWNTIME_PERCENTAGE</td>
<td style="text-align:center">百分比修改重生时间</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_RESPAWNTIME_STACKING</td>
<td style="text-align:center">累积重生时间</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_STATS_AGILITY_BONUS</td>
<td style="text-align:center">修改敏捷</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_STATS_INTELLECT_BONUS</td>
<td style="text-align:center">修改智力</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_STATS_STRENGTH_BONUS</td>
<td style="text-align:center">修改力量</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_SUPER_ILLUSION_WITH_ULTIMATE</td>
<td style="text-align:center">VS A杖大招的那个幻象</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_TOOLTIP</td>
<td style="text-align:center">可被用于任何提示， 比如臂章的血量移除</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_TOTAL_CONSTANT_BLOCK</td>
<td style="text-align:center">减免所有来源的伤害</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_TOTAL_CONSTANT_BLOCK_UNAVOIDABLE_PRE_ARMOR</td>
<td style="text-align:center">对于自动攻击的伤害减免</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_TOTALDAMAGEOUTGOING_PERCENTAGE</td>
<td style="text-align:center">失效，不工作</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_TRANSLATE_ACTIVITY_MODIFIERS</td>
<td style="text-align:center">动作修改？</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_TRANSLATE_ATTACK_SOUND</td>
<td style="text-align:center">攻击音效修改？</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_PROPERTY_TURN_RATE_PERCENTAGE</td>
<td style="text-align:center">百分比修改转向速度</td>
</tr>
</tbody>
</table>
<h2 id="modifier-状态"><a class="markdownIt-Anchor" href="#modifier-状态"></a> Modifier 状态</h2>
<p>Modifier状态和Modifier属性十分类似，只不过他们是只有三个数值：“MODIFIER_STATE_VALUE_NO_ACTION”(不作为), “MODIFIER_STATE_VALUE_ENABLED”(启用) 或者 “MODIFIER_STATE_VALUE_DISABLED”(禁用)。以下的modifier示例给单位添加了一个简单的眩晕粒子特效，覆盖了单位的模型操作，让单位进入了眩晕状态。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">"creature_bash_ministun"</span><br><span class="line">{</span><br><span class="line">    "Duration"              "%duration"</span><br><span class="line">    "EffectName"            "generic_stunned"</span><br><span class="line">    "EffectAttachType"      "follow_overhead"</span><br><span class="line">    "Duration"              "%stun_duration"</span><br><span class="line">    "OverrideAnimation"     "ACT_DOTA_DISABLED"</span><br><span class="line">    "States"</span><br><span class="line">    {</span><br><span class="line">        "MODIFIER_STATE_STUNNED" "MODIFIER_STATE_VALUE_ENABLED"</span><br><span class="line">    }       </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="modifier状态列表"><a class="markdownIt-Anchor" href="#modifier状态列表"></a> Modifier状态列表</h3>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MODIFIER_STATE_ATTACK_IMMUNE</td>
<td style="text-align:center">攻击免疫状态</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_BLIND</td>
<td style="text-align:center">致盲状态？无法物理攻击？</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_BLOCK_DISABLED</td>
<td style="text-align:center">禁用伤害减免？</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_CANNOT_MISS</td>
<td style="text-align:center">不能闪避？</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_COMMAND_RESTRICTED</td>
<td style="text-align:center">禁魔状态</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_DISARMED</td>
<td style="text-align:center">缴械状态</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_DOMINATED</td>
<td style="text-align:center">支配状态？</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_EVADE_DISABLED</td>
<td style="text-align:center">禁用躲避？</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_FLYING</td>
<td style="text-align:center">飞行状态</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_FROZEN</td>
<td style="text-align:center">冷冻状态</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_HEXED</td>
<td style="text-align:center">妖术状态</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_INVISIBLE</td>
<td style="text-align:center">隐身状态</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_INVULNERABLE</td>
<td style="text-align:center">无敌状态</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_LOW_ATTACK_PRIORITY</td>
<td style="text-align:center">低的攻击优先级</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_MAGIC_IMMUNE</td>
<td style="text-align:center">魔法免疫状态</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_MUTED</td>
<td style="text-align:center">禁用物品状态</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_NIGHTMARED</td>
<td style="text-align:center">催眠状态</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_NO_HEALTH_BAR</td>
<td style="text-align:center">没有生命条</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_NO_TEAM_MOVE_TO</td>
<td style="text-align:center">没有移动到队伍状态</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_NO_TEAM_SELECT</td>
<td style="text-align:center">没有选择队伍状态</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_NOT_ON_MINIMAP</td>
<td style="text-align:center">不在小地图状态</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_NOT_ON_MINIMAP_FOR_ENEMIES</td>
<td style="text-align:center">敌人不在小地图状态</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_NO_UNIT_COLLISION</td>
<td style="text-align:center">没有单位碰撞状态</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_OUT_OF_GAME</td>
<td style="text-align:center">离开游戏状态</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_PASSIVES_DISABLED</td>
<td style="text-align:center">禁用被动技能状态</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_PROVIDES_VISION</td>
<td style="text-align:center">提供视野状态</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_ROOTED</td>
<td style="text-align:center">被缠绕状态</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_SILENCED</td>
<td style="text-align:center">沉默状态</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_SOFT_DISARMED</td>
<td style="text-align:center">软解除武装状态</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_SPECIALLY_DENIABLE</td>
<td style="text-align:center"><em>暂无说明</em></td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_STUNNED</td>
<td style="text-align:center">眩晕状态</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_STATE_UNSELECTABLE</td>
<td style="text-align:center">无法选取状态</td>
</tr>
</tbody>
</table>
<h2 id="modifier-事件"><a class="markdownIt-Anchor" href="#modifier-事件"></a> Modifier 事件</h2>
<p>Modifiers也可以定义一些触发事件，以下的这些事件能够在modifier中定义 - 操作在本页面其他位置已经提及了</p>
<table>
<thead>
<tr>
<th style="text-align:center">触发事件名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">OnAttacked</td>
<td style="text-align:center">当拥有modifier的单位被攻击时</td>
</tr>
<tr>
<td style="text-align:center">OnAttackLanded</td>
<td style="text-align:center">当拥有modifier的单位攻击到某个目标时</td>
</tr>
<tr>
<td style="text-align:center">OnAttackStart</td>
<td style="text-align:center">当拥有modifier的单位开始攻击某个目标</td>
</tr>
<tr>
<td style="text-align:center">OnCreated</td>
<td style="text-align:center">当modifier被创建时</td>
</tr>
<tr>
<td style="text-align:center">OnDealDamage</td>
<td style="text-align:center">当拥有modifier的单位施加伤害的时候</td>
</tr>
<tr>
<td style="text-align:center">OnDeath</td>
<td style="text-align:center">当拥有modifier的单位死亡的时候</td>
</tr>
<tr>
<td style="text-align:center">OnDestroy</td>
<td style="text-align:center">当这个modifier被移除的时候</td>
</tr>
<tr>
<td style="text-align:center">OnOrbFire</td>
<td style="text-align:center">当法球modifier的法球被释放的时候</td>
</tr>
<tr>
<td style="text-align:center">OnOrbImpact</td>
<td style="text-align:center">当法球modifier的法球命中目标之后</td>
</tr>
<tr>
<td style="text-align:center">OnTakeDamage</td>
<td style="text-align:center">当拥有modifier的单位受到伤害的时候</td>
</tr>
<tr>
<td style="text-align:center">Orb</td>
<td style="text-align:center">定义一个法球modifeir的特效等</td>
</tr>
<tr>
<td style="text-align:center">OnIntervalThink</td>
<td style="text-align:center">循环执行定时器操作。在CreateThinker(创建定时器)下使用，配合Duration(持续时间)，ThinkInterval(间隔)。</td>
</tr>
<tr>
<td style="text-align:center">新事件(14/08/26更新)</td>
<td style="text-align:center">描述</td>
</tr>
<tr>
<td style="text-align:center">OnAttack</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">OnAttackFailed</td>
<td style="text-align:center">当拥有modifier的单位攻击失败时</td>
</tr>
<tr>
<td style="text-align:center">OnAttackAllied</td>
<td style="text-align:center">当拥有modifier的单位攻击盟友时</td>
</tr>
<tr>
<td style="text-align:center">OnProjectileDodge</td>
<td style="text-align:center">当拥有modifier的单位闪避弹道粒子特效时</td>
</tr>
<tr>
<td style="text-align:center">OnEquip</td>
<td style="text-align:center">当拥有modifier的单位装备物品</td>
</tr>
<tr>
<td style="text-align:center">OnOrder</td>
<td style="text-align:center">当拥有modifier的单位执行指令</td>
</tr>
<tr>
<td style="text-align:center">OnUnitMoved</td>
<td style="text-align:center">当拥有modifier的单位移动的时候</td>
</tr>
<tr>
<td style="text-align:center">OnAbilityStart</td>
<td style="text-align:center">当拥有modifier的单位开始使用技能</td>
</tr>
<tr>
<td style="text-align:center">OnAbilityEndChannel</td>
<td style="text-align:center">当拥有modifier的单位结束持续施法</td>
</tr>
<tr>
<td style="text-align:center">OnStateChanged</td>
<td style="text-align:center">当拥有modifier的单位状态改变时</td>
</tr>
<tr>
<td style="text-align:center">OnRespawn</td>
<td style="text-align:center">当拥有modifier的单位重生</td>
</tr>
<tr>
<td style="text-align:center">OnSpentMana</td>
<td style="text-align:center">当拥有modifier的单位花费魔法时</td>
</tr>
<tr>
<td style="text-align:center">OnTeleporting</td>
<td style="text-align:center">当拥有modifier的单位正在传送时</td>
</tr>
<tr>
<td style="text-align:center">OnTeleported</td>
<td style="text-align:center">当拥有modifier的单位传送结束时</td>
</tr>
<tr>
<td style="text-align:center">OnHealthGained</td>
<td style="text-align:center">当拥有modifier的单位获得生命值</td>
</tr>
<tr>
<td style="text-align:center">OnManaGained</td>
<td style="text-align:center">当拥有modifier的单位获得魔法值</td>
</tr>
<tr>
<td style="text-align:center">OnHeroKilled</td>
<td style="text-align:center">当拥有modifier的单位被英雄杀了</td>
</tr>
<tr>
<td style="text-align:center">OnHealReceived</td>
<td style="text-align:center">当拥有modifier的单位受到治疗</td>
</tr>
</tbody>
</table>
<h3 id="modifier事件列表"><a class="markdownIt-Anchor" href="#modifier事件列表"></a> Modifier事件列表</h3>
<p>这些事件并不可以应用在所有的数据驱动类技能中，仅作为参考。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_ABILITY_END_CHANNEL</td>
<td style="text-align:center">当持续性施法完成</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_ABILITY_EXECUTED</td>
<td style="text-align:center">当施法执行完</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_ABILITY_START</td>
<td style="text-align:center">当施法开始时</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_ATTACK</td>
<td style="text-align:center">当攻击时</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_ATTACK_ALLIED</td>
<td style="text-align:center">当攻击盟军时</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_ATTACKED</td>
<td style="text-align:center">当攻击结束时</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_ATTACK_FAIL</td>
<td style="text-align:center">当攻击失败</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_ATTACK_LANDED</td>
<td style="text-align:center">当攻击击中时</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_ATTACK_START</td>
<td style="text-align:center">当攻击开始时</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_BREAK_INVISIBILITY</td>
<td style="text-align:center">当打破隐身状态</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_DEATH</td>
<td style="text-align:center">当死亡时</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_HEAL_RECEIVED</td>
<td style="text-align:center">当收到治疗</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_HEALTH_GAINED</td>
<td style="text-align:center">当获得生命值</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_HERO_KILLED</td>
<td style="text-align:center">当英雄死亡</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_MANA_GAINED</td>
<td style="text-align:center">当获得魔法值</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_ORB_EFFECT</td>
<td style="text-align:center">当在法球效果</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_ORDER</td>
<td style="text-align:center">当命令结束时</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_PROCESS_UPGRADE</td>
<td style="text-align:center">当在升级过程中</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_PROJECTILE_DODGE</td>
<td style="text-align:center">当闪避弹道时</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_REFRESH</td>
<td style="text-align:center">当刷新时</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_RESPAWN</td>
<td style="text-align:center">当重生时</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_SPENT_MANA</td>
<td style="text-align:center">当花费魔法值时</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_STATE_CHANGED</td>
<td style="text-align:center">当状态改变时</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_TAKEDAMAGE</td>
<td style="text-align:center">当带来伤害时</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_TAKEDAMAGE_REAPERSCYTHE</td>
<td style="text-align:center">当在死神镰刀下带来伤害时</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_TELEPORTED</td>
<td style="text-align:center">当在传送结束时</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_TELEPORTING</td>
<td style="text-align:center">当正在传送时</td>
</tr>
<tr>
<td style="text-align:center">MODIFIER_EVENT_ON_UNIT_MOVED</td>
<td style="text-align:center">当单位移动时</td>
</tr>
</tbody>
</table>
<h1 id="数据驱动类技能范例"><a class="markdownIt-Anchor" href="#数据驱动类技能范例"></a> 数据驱动类技能范例</h1>
<p>&lt; <a href="https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools:zh-cn">Dota 2 Workshop Tools:zh-cn</a>‎ | <a href="https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools:zh-cn/Scripting:zh-cn">Scripting:zh-cn</a><br>
<strong><a href="https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools/Scripting/Abilities_Data_Driven_Examples"><img src="https://developer.valvesoftware.com/w/images/3/3b/En.png" alt="English"></a></strong></p>
<h2 id="contents"><a class="markdownIt-Anchor" href="#contents"></a> Contents</h2>
<p>[hide]</p>
<ul>
<li><a href="https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools:zh-cn/Scripting:zh-cn/Abilities_Data_Driven_Example:zh-cn#.E5.8D.95.E4.BD.8D.E6.AD.BB.E4.BA.A1.E5.90.8E.E9.80.A0.E6.88.90.E6.8C.81.E7.BB.AD.E6.80.A7.E8.8C.83.E5.9B.B4.E4.BC.A4.E5.AE.B3.E7.9A.84.E4.BE.8B.E5.AD.90">1单位死亡后造成持续性范围伤害的例子</a></li>
<li><a href="https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools:zh-cn/Scripting:zh-cn/Abilities_Data_Driven_Example:zh-cn#.E4.B8.80.E4.B8.AA.E6.B3.95.E7.90.83.E7.9A.84.E5.AE.9E.E4.BE.8B">2一个法球的实例</a></li>
<li><a href="https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools:zh-cn/Scripting:zh-cn/Abilities_Data_Driven_Example:zh-cn#.E7.B3.BB.E7.BB.9F.E5.85.89.E7.8E.AF.E5.AE.9E.E4.BE.8B">3系统光环实例</a></li>
<li><a href="https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools:zh-cn/Scripting:zh-cn/Abilities_Data_Driven_Example:zh-cn#.E4.B8.80.E4.B8.AA.E8.87.AA.E5.AE.9A.E4.B9.89.E7.9A.84.E5.85.89.E7.8E.AF.E5.AE.9E.E4.BE.8B">4一个自定义的光环实例</a></li>
</ul>
<h2 id="单位死亡后造成持续性范围伤害的例子"><a class="markdownIt-Anchor" href="#单位死亡后造成持续性范围伤害的例子"></a> 单位死亡后造成持续性范围伤害的例子</h2>
<p>本示例在技能被添加之后，将会等到拥有者死亡之后触发，当拥有者死亡的时候，一个带有酸雾特效和一个降低目标区域的单位护甲并施加伤害的计时器将会被创建。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">//=================================================================================================================</span><br><span class="line">// Creature: Acid Spray</span><br><span class="line">//=================================================================================================================</span><br><span class="line">"creature_acid_spray"</span><br><span class="line">{</span><br><span class="line"> // General</span><br><span class="line"> //-------------------------------------------------------------------------------------------------------------</span><br><span class="line"> "BaseClass" 					"ability_datadriven"</span><br><span class="line"> "AbilityBehavior"				"DOTA_ABILITY_BEHAVIOR_AOE"</span><br><span class="line"> "AbilityUnitDamageType"			"DAMAGE_TYPE_COMPOSITE"</span><br><span class="line"> "AbilityTextureName"			"alchemist_acid_spray"</span><br><span class="line"> // Casting</span><br><span class="line"> //-------------------------------------------------------------------------------------------------------------</span><br><span class="line"> "AbilityCastPoint"				"0.2"</span><br><span class="line"> "AbilityCastRange"				"900"</span><br><span class="line"> "OnOwnerDied"</span><br><span class="line"> {</span><br><span class="line">   "CreateThinker"</span><br><span class="line">   {</span><br><span class="line">    "ModifierName" "creature_acid_spray_thinker"</span><br><span class="line">    "Target" "CASTER"</span><br><span class="line">   }</span><br><span class="line"> }</span><br><span class="line"> "Modifiers"</span><br><span class="line"> {</span><br><span class="line">  "creature_acid_spray_thinker"</span><br><span class="line">  {</span><br><span class="line">   "Aura" "create_acid_spray_armor_reduction_aura"</span><br><span class="line">   "Aura_Radius" "%radius"</span><br><span class="line">   "Aura_Teams" "DOTA_UNIT_TARGET_TEAM_ENEMY"</span><br><span class="line">   "Aura_Types" "DOTA_UNIT_TARGET_HERO | DOTA_UNIT_TARGET_CREEP | DOTA_UNIT_TARGET_MECHANICAL"</span><br><span class="line">   "Aura_Flags" "DOTA_UNIT_TARGET_FLAG_MAGIC_IMMUNE_ENEMIES"</span><br><span class="line">   "Duration" "%duration"</span><br><span class="line">   "OnCreated"</span><br><span class="line">   {</span><br><span class="line">    "AttachEffect"</span><br><span class="line">    {</span><br><span class="line">      "EffectName" "alchemist_acid_spray"</span><br><span class="line">      "EffectAttachType" "follow_origin"</span><br><span class="line">      "Target" "TARGET"</span><br><span class="line">      "ControlPoints"</span><br><span class="line">      {</span><br><span class="line">       "00" "0 0 0"</span><br><span class="line">       "01" "%radius 1 1"</span><br><span class="line">      }</span><br><span class="line">     }</span><br><span class="line">    }</span><br><span class="line">   }</span><br><span class="line">   "create_acid_spray_armor_reduction_aura"</span><br><span class="line">   {</span><br><span class="line">    "IsDebuff" "1"</span><br><span class="line">    "IsPurgable" "0"</span><br><span class="line">    "EffectName" "alchemist_acid_spray_debuff"			</span><br><span class="line">    "ThinkInterval" "%tick_rate"</span><br><span class="line">    "OnIntervalThink"</span><br><span class="line">    {</span><br><span class="line">      "Damage"</span><br><span class="line">      {</span><br><span class="line">       "Type" "DAMAGE_TYPE_COMPOSITE"</span><br><span class="line">       "Damage" "%damage"</span><br><span class="line">       "Target" "TARGET"</span><br><span class="line">      }</span><br><span class="line">     }</span><br><span class="line">     "Properties"</span><br><span class="line">     {</span><br><span class="line">       "MODIFIER_PROPERTY_PHYSICAL_ARMOR_BONUS" "%armor_reduction"</span><br><span class="line">     }</span><br><span class="line">    }</span><br><span class="line">   }</span><br><span class="line"> // Special</span><br><span class="line"> //-------------------------------------------------------------------------------------------------------------</span><br><span class="line"> "AbilitySpecial"</span><br><span class="line"> {</span><br><span class="line">  "01"</span><br><span class="line">  {</span><br><span class="line">   "var_type"				"FIELD_INTEGER"</span><br><span class="line">   "radius"				"250"</span><br><span class="line">  }</span><br><span class="line">  "02"</span><br><span class="line">  {</span><br><span class="line">   "var_type"				"FIELD_FLOAT"</span><br><span class="line">   "duration"				"16.0"</span><br><span class="line">  }</span><br><span class="line">  "03"</span><br><span class="line">  {</span><br><span class="line">   "var_type"				"FIELD_INTEGER"</span><br><span class="line">   "damage"				"118 128 138 158"</span><br><span class="line">  }</span><br><span class="line">  "04"</span><br><span class="line">  {</span><br><span class="line">   "var_type"				"FIELD_INTEGER"</span><br><span class="line">   "armor_reduction"		        "-3 -4 -5 -6"</span><br><span class="line">  }</span><br><span class="line">  "05"</span><br><span class="line">  {</span><br><span class="line">   "var_type"				"FIELD_FLOAT"</span><br><span class="line">   "tick_rate"				"1.0"</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="一个法球的实例"><a class="markdownIt-Anchor" href="#一个法球的实例"></a> 一个法球的实例</h2>
<p>一个可以造成范围性伤害和晕眩的法球实例。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">"testOrb_Example"</span><br><span class="line"> {</span><br><span class="line">    "ID"    "10003"</span><br><span class="line">    "BaseClass"    "ability_datadriven"</span><br><span class="line">    "AbilityBehavior"    "DOTA_ABILITY_BEHAVIOR_UNIT_TARGET | DOTA_ABILITY_BEHAVIOR_AUTOCAST| DOTA_ABILITY_BEHAVIOR_ATTACK"</span><br><span class="line">    "AbilityUnitTargetTeam"    "DOTA_UNIT_TARGET_TEAM_ENEMY"</span><br><span class="line">    "AbilityUnitTargetType"    "DOTA_UNIT_TARGET_ALL"</span><br><span class="line">    "MaxLevel"    "1"</span><br><span class="line">    "AbilityCastPoint"    "0.0"</span><br><span class="line">    "AbilityCastRange"    "900"</span><br><span class="line">    "AbilityCooldown"    "0"</span><br><span class="line">    "AbilityManaCost"    "10"</span><br><span class="line">    "AbilitySpecial"</span><br><span class="line">    {</span><br><span class="line">        "01"</span><br><span class="line">        {</span><br><span class="line">            "var_type"    "FIELD_INTEGER"</span><br><span class="line">            "RangeDamage"    "75"</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    "Modifiers"</span><br><span class="line">    {</span><br><span class="line">        "TestOrb_Modifier"</span><br><span class="line">        {</span><br><span class="line">            "Passive"    "1"</span><br><span class="line">            "IsHidden"    "1"</span><br><span class="line">            "Orb"</span><br><span class="line">            {</span><br><span class="line">                "Priority"    "DOTA_ORB_PRIORITY_ABILITY"//法球的类型</span><br><span class="line">                //下面是一个投射物特效的定义，值得一提的是，不少粒子效果是无法形成正常的投射物效果，而是会直接附着到目标上面播放。</span><br><span class="line">                "ProjectileName"    "particles/units/heroes/hero_sven/sven_spell_storm_bolt.vpcf"</span><br><span class="line">                "CastAttack"    "1"</span><br><span class="line">            }</span><br><span class="line">            "OnOrbFire"</span><br><span class="line">            {</span><br><span class="line">                //这下面的设定会使得当你右键激活自动释放时进行普通攻击也能正常消耗魔法，否则激活自动释放状态下不会消耗魔法。</span><br><span class="line">                "SpendMana"</span><br><span class="line">                {</span><br><span class="line">                    "Mana"    "%AbilityManaCost"</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            "OnOrbImpact"</span><br><span class="line">            {</span><br><span class="line">                "FireEffect"</span><br><span class="line">                {</span><br><span class="line">                    "EffectName"    "particles/units/heroes/hero_sven/sven_spell_warcry.vpcf"</span><br><span class="line">                    "EffectAttachType"    "attach_hitloc"</span><br><span class="line">                    "Target"    "TARGET"</span><br><span class="line">                }</span><br><span class="line">                "Damage"//对范围内单位造成伤害</span><br><span class="line">                {</span><br><span class="line">                    "Type"    "DAMAGE_TYPE_PURE"</span><br><span class="line">                    "Damage"    "%RangeDamage"//和AbilitySpecial里定义的RangeDamage上对应数值挂钩。</span><br><span class="line">                    "Target"</span><br><span class="line">                    {</span><br><span class="line">                        "Center"    "TARGET"</span><br><span class="line">                        "Teams"    "DOTA_UNIT_TARGET_TEAM_ENEMY"</span><br><span class="line">                        "Type"    "DOTA_UNIT_TARGET_ALL"</span><br><span class="line">                        "Radius"    "275"</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                "Stun"//击晕范围内单位</span><br><span class="line">                {</span><br><span class="line">                    "Duration"    "2"</span><br><span class="line">                    "Target"</span><br><span class="line">                    {</span><br><span class="line">                        "Center"    "TARGET"</span><br><span class="line">                        "Teams"    "DOTA_UNIT_TARGET_TEAM_ENEMY"</span><br><span class="line">                        "Type"    "DOTA_UNIT_TARGET_ALL"</span><br><span class="line">                        "Radius"    "275"</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<h2 id="系统光环实例"><a class="markdownIt-Anchor" href="#系统光环实例"></a> 系统光环实例</h2>
<p>一个普通的系统光环实现，效果是范围内敌军减少50%攻击力。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">"TestSysAura"</span><br><span class="line"> {</span><br><span class="line">  "BaseClass" "ability_datadriven"</span><br><span class="line">  "AbilityBehavior" "DOTA_ABILITY_BEHAVIOR_AURA | DOTA_ABILITY_BEHAVIOR_PASSIVE"</span><br><span class="line">  "AbilityUnitTargetTeam" "DOTA_UNIT_TARGET_TEAM_ENEMY"</span><br><span class="line">  "AbilityUnitTargetType" "DOTA_UNIT_TARGET_ALL"</span><br><span class="line">  "AbilityTextureName" "alchemist_acid_spray"</span><br><span class="line">  "MaxLevel" "1"</span><br><span class="line"></span><br><span class="line">  "AbilityCastPoint"    "0.0"</span><br><span class="line">  "AbilityCastRange"    "500"</span><br><span class="line">  "AbilityCooldown"    "0"</span><br><span class="line">  "AbilityManaCost"    "0"</span><br><span class="line"></span><br><span class="line">  "AbilitySpecial"</span><br><span class="line">  {</span><br><span class="line">   "01"</span><br><span class="line">   {</span><br><span class="line">    "var_type" "FIELD_INTEGER"</span><br><span class="line">    "Range" "500"</span><br><span class="line">   }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  "Modifiers"</span><br><span class="line">  {</span><br><span class="line">   "TestSysAura_Modifier"</span><br><span class="line">   {</span><br><span class="line">    "Passive" "1"</span><br><span class="line">    "IsHidden" "1"</span><br><span class="line">    "Aura" "TestSysAura_FixAttackPercent"</span><br><span class="line">    "Aura_Radius" "%Range"</span><br><span class="line">    "Aura_Teams" "DOTA_UNIT_TARGET_TEAM_ENEMY"</span><br><span class="line">    "Aura_Types" "DOTA_UNIT_TARGET_ALL"</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   "TestSysAura_FixAttackPercent"</span><br><span class="line">   {</span><br><span class="line">    "IsDebuff" "1"</span><br><span class="line">    "IsPurgable" "0"</span><br><span class="line">    "Properties"</span><br><span class="line">    {</span><br><span class="line">     "MODIFIER_PROPERTY_DAMAGEOUTGOING_PERCENTAGE" "-50"</span><br><span class="line">    }</span><br><span class="line">   }</span><br><span class="line">  }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<h2 id="一个自定义的光环实例"><a class="markdownIt-Anchor" href="#一个自定义的光环实例"></a> 一个自定义的光环实例</h2>
<p>这个光环的效果和上面那个光环的效果一样。 但是通过这个我们可以在lua中得到光环的拥有者和作用单位。于是可以在lua里面对这些实体进行各种额外的操作。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">//在lua中我们可以获取到一下entity</span><br><span class="line">//    光环拥有者    -&gt; EntIndexToHScript(keys.caster_entindex)</span><br><span class="line">// 被光环作用的单位 -&gt; keys.target</span><br><span class="line"> "TestCustomAura"</span><br><span class="line"> {</span><br><span class="line">  "BaseClass" "ability_datadriven"</span><br><span class="line">  "AbilityBehavior" "DOTA_ABILITY_BEHAVIOR_AURA | DOTA_ABILITY_BEHAVIOR_PASSIVE"</span><br><span class="line">  "AbilityUnitTargetTeam" "DOTA_UNIT_TARGET_TEAM_ENEMY"</span><br><span class="line">  "AbilityUnitTargetType" "DOTA_UNIT_TARGET_ALL"</span><br><span class="line">  "AbilityTextureName" "alchemist_acid_spray"</span><br><span class="line">  "MaxLevel" "1"</span><br><span class="line"></span><br><span class="line">  "AbilityCastPoint"    "0.0"</span><br><span class="line">  "AbilityCastRange"    "500"</span><br><span class="line">  "AbilityCooldown"    "0"</span><br><span class="line">  "AbilityManaCost"    "0"</span><br><span class="line"></span><br><span class="line">  "AbilitySpecial"</span><br><span class="line">  {</span><br><span class="line">   "01"</span><br><span class="line">   {</span><br><span class="line">    "var_type" "FIELD_INTEGER"</span><br><span class="line">    "Range" "500"</span><br><span class="line">   }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  "Modifiers"</span><br><span class="line">  {</span><br><span class="line">   "TestCustomAura_Modifier"</span><br><span class="line">   {</span><br><span class="line">    "Passive" "1"</span><br><span class="line">    "IsHidden" "1"</span><br><span class="line"></span><br><span class="line">    "ThinkInterval"  "0.5"</span><br><span class="line">    "OnIntervalThink"</span><br><span class="line">    {</span><br><span class="line">     "ApplyModifier"</span><br><span class="line">     {</span><br><span class="line">      "ModifierName" "TestCustomAura_FixAttackPercentIcon"</span><br><span class="line">      "Target"</span><br><span class="line">      {</span><br><span class="line">       "Teams"  "DOTA_UNIT_TARGET_TEAM_ENEMY"</span><br><span class="line">       "Types"  "DOTA_UNIT_TARGET_ALL"</span><br><span class="line">       "Center" "CASTER"</span><br><span class="line">       "Radius" "%Range"</span><br><span class="line">      }</span><br><span class="line">     }</span><br><span class="line">     "ApplyModifier"</span><br><span class="line">     {</span><br><span class="line">      "ModifierName" "TestCustomAura_FixAttackPercentTimer"</span><br><span class="line">      "Target"</span><br><span class="line">      {</span><br><span class="line">       "Teams"  "DOTA_UNIT_TARGET_TEAM_ENEMY"</span><br><span class="line">       "Types"  "DOTA_UNIT_TARGET_ALL"</span><br><span class="line">       "Center" "CASTER"</span><br><span class="line">       "Radius" "%Range"</span><br><span class="line">      }</span><br><span class="line">     }</span><br><span class="line">    }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   "TestCustomAura_FixAttackPercentIcon"</span><br><span class="line">   {</span><br><span class="line">    "IsDebuff" "1"</span><br><span class="line">    "IsPurgable" "0"</span><br><span class="line">    "TextureName" "alchemist_acid_spray"</span><br><span class="line">    "Properties"</span><br><span class="line">    {</span><br><span class="line">     "MODIFIER_PROPERTY_DAMAGEOUTGOING_PERCENTAGE" "-50"</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   "TestCustomAura_FixAttackPercentTimer"</span><br><span class="line">   {</span><br><span class="line">    "IsDebuff" "1"</span><br><span class="line">    "IsPurgable" "0"</span><br><span class="line">    "IsHidden" "1"</span><br><span class="line">    "Duration" "0.6"</span><br><span class="line">    "OnDestroy"</span><br><span class="line">    {</span><br><span class="line">     "RemoveModifier"</span><br><span class="line">     {</span><br><span class="line">      "ModifierName" "TestCustomAura_FixAttackPercentIcon"</span><br><span class="line">      "Target" "TARGET"</span><br><span class="line">     }</span><br><span class="line">    }</span><br><span class="line">   }</span><br><span class="line">  }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<p><a href="https://developer.valvesoftware.com/wiki/Special:Categories">Categories</a>:</p>
<ul>
<li><a href="https://developer.valvesoftware.com/wiki/Category:Dota_2_%E5%88%9B%E6%84%8F%E5%B7%A5%E5%9D%8A%E5%B7%A5%E5%85%B7%E9%9B%86">Dota 2 创意工坊工具集</a></li>
<li><a href="https://developer.valvesoftware.com/wiki/Category:AMHC_%E6%B1%89%E5%8C%96">AMHC 汉化</a></li>
</ul>
<!--stackedit_data:
eyJoaXN0b3J5IjpbODYxNDE2MjE0LDM1OTU1MDQ5OSwtMjA4OD
c0NjYxMiwtMTA3ODE5OTc2NiwxOTIxMzQ0NzgzLC0xMTAyNTMw
MDAwLDE3NTM3MjYwMzgsLTE0MzU2NDIzNSwtMTE5MDE1MzQwNS
wtMzQ1NDQyNDgzLC0xMTE4MDU1NjMsLTUzMjQwNzMzNiwtMTE5
MzYyMzgzMF19
-->
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>技能</tag>
      </tags>
  </entry>
  <entry>
    <title>Erlang 读书笔记</title>
    <url>/2017/12/24/ReadingNotes/</url>
    <content><![CDATA[<h1 id="erlang-读书笔记"><a class="markdownIt-Anchor" href="#erlang-读书笔记"></a> Erlang 读书笔记</h1>
<ul>
<li>erlang:byte_size/0查看binary的字节数量</li>
<li>erts_debug:flat_size查看变量所占的内存字节数</li>
<li>erlang timeout的语义是保证事件不会再给定的时间之前触发，就是触发时间&gt;=给定的时间</li>
<li>Terms are created on the heap by evaluating expressions.</li>
</ul>
<blockquote>
<p>There are two major types of terms:<br>
<a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_term.h#L88-L97">immediate terms</a> which require no heap space (small integers, atoms, pids, port ids etc) and cons<br>
<a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_term.h#L106-L120">boxed terms</a> (tuple, big num, binaries etc) that do require heap space.<br>
Immediate terms do not need any heap space because they are embedded into the containing structure.</p>
</blockquote>
<span id="more"></span>
<ul>
<li>进程字典实现</li>
</ul>
<blockquote>
<p>由数组实现hash结构，每个都是键值对存放于进程的Heap上<br>
根据key来算hash值，没有冲突就把{Key，Val}存入数组&gt; 如果有key冲突就是存从一个键值对列表，如果要更新一个Key，将会导致整个bucket被重新分配，确保没有获取到 从old heap指向 new heap的指针</p>
</blockquote>
<ul>
<li>进程的内存由 stack 、heap、 mailbox、 PCB构成</li>
</ul>
<blockquote>
<p>stack：函数返回地址、函数参数、局部变量<br>
heap: lists 、tuple<br>
mailbox:待处理的消息<br>
PCB： 进程控制块</p>
</blockquote>
<ul>
<li>可以使用hipe_bifs:show_*查看进程栈、堆、PCB 内存数据 <em><strong>（仅供调试）</strong></em></li>
</ul>
<blockquote>
<p>hipe_bifs:show_estack/1<br>
hipe_bifs:show_heap/1<br>
hipe_bifs:show_pcb/1</p>
</blockquote>
<ul>
<li>PCB 内部结构</li>
</ul>
<figure class="highlight erlang"><table><tbody><tr><td class="code"><pre><span class="line">---------------------------------------------------------------</span><br><span class="line">Offset| Name        | Value              | *Value             |</span><br><span class="line">    0 | id          | 0x000001d0000003a3 |PID             </span><br><span class="line">   72 | htop        | 0x00007f7f33f15298 |pointers to the top of the heap                   </span><br><span class="line">   96 | hend        | 0x00007f7f33f16540 |points to the stop of the whole heap                  </span><br><span class="line">   88 | heap        | 0x00007f7f33f11470 |points to heap start                 </span><br><span class="line">  104 | heap_sz     | 0x0000000000000a1a | gives the size of the heap in words <span class="params">(hend - heap = heap_sz * <span class="number">8</span> on a <span class="number">64</span> bit machine )</span>                    </span><br><span class="line">   80 | stop        | 0x00007f7f33f16480 |pointers to the top of the stack                   </span><br><span class="line">  592 | gen_gcs     | 0x0000000000000012 |Number of <span class="params">(minor)</span> generational GCs.</span><br><span class="line">  <span class="number">594</span> | max_gen_gcs | <span class="number">0</span>x000000000000ffff |Max minor gen GCs before fullsweep.</span><br><span class="line">  <span class="number">552</span> | high_water  | <span class="number">0</span>x00007f7f33f11c50 |                    |</span><br><span class="line">  <span class="number">560</span> | old_hend    | <span class="number">0</span>x00007f7f33e90648 |                    |</span><br><span class="line">  <span class="number">568</span> | old_htop    | <span class="number">0</span>x00007f7f33e8f8e8 |                    |</span><br><span class="line">  <span class="number">576</span> | old_head    | <span class="number">0</span>x00007f7f33e8e770 |                    |</span><br><span class="line">  <span class="number">112</span> | min_heap_size | <span class="number">0</span>x00000000000000e9 |in words, that the heap starts with <span class="keyword">and</span> which it will <span class="keyword">not</span> shrink smaller than, the default value is <span class="number">233</span>.</span><br><span class="line">  <span class="number">328</span> | rcount      | <span class="number">0</span>x0000000000000000 | suspend count </span><br><span class="line">  <span class="number">336</span> | reds        | <span class="number">0</span>x0000000000002270 | keep track <span class="keyword">of</span> the total number <span class="keyword">of</span> reductions a process has done up until it was last suspended  </span><br><span class="line">   <span class="number">16</span> | tracer      | <span class="number">0</span>xfffffffffffffffb |                    |</span><br><span class="line">   <span class="number">24</span> | trace_fla.. | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">  <span class="number">344</span> | group_lea.. | <span class="number">0</span>x0000019800000333 |                    |</span><br><span class="line">  <span class="number">352</span> | flags       | <span class="number">0</span>x0000000000002000 |Trap exit, etc (no trace flags anymore)                    </span><br><span class="line">  <span class="number">360</span> | fvalue      | <span class="number">0</span>xfffffffffffffffb |Exit &amp; Throw value (failure reason)</span><br><span class="line">  <span class="number">368</span> | freason     | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">  <span class="number">320</span> | fcalls      | <span class="number">0</span>x00000000000005a2 | keeps the number <span class="keyword">of</span> reductions left to execute   </span><br><span class="line">  <span class="number">384</span> | next        | <span class="number">0</span>x0000000000000000 |next ready(runnable) process  in the ready queue <span class="keyword">of</span> scheduler    </span><br><span class="line">   <span class="number">48</span> | reg         | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">   <span class="number">56</span> | nlinks      | <span class="number">0</span>x00007f7f3cbc0750 |                    |</span><br><span class="line">  <span class="number">616</span> | mbuf        | <span class="number">0</span>x0000000000000000 |a memory area outside <span class="keyword">of</span> a process heap where other processes can safely write data                    </span><br><span class="line">  <span class="number">640</span> | mbuf_sz     | <span class="number">0</span>x0000000000000000 |Total size <span class="keyword">of</span> heap fragments <span class="keyword">and</span> message fragments</span><br><span class="line">  <span class="number">464</span> | dictionary  | <span class="number">0</span>x0000000000000000 | Process Dictionary                   </span><br><span class="line">  <span class="number">472</span> | seq..clock  | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">  <span class="number">480</span> | seq..astcnt | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">  <span class="number">488</span> | seq..token  | <span class="number">0</span>xfffffffffffffffb |                    |</span><br><span class="line">  <span class="number">496</span> | intial[<span class="number">0</span>]   | <span class="number">0</span>x000000000000320b |                    |</span><br><span class="line">  <span class="number">504</span> | intial[<span class="number">1</span>]   | <span class="number">0</span>x0000000000000c8b |                    |</span><br><span class="line">  <span class="number">512</span> | intial[<span class="number">2</span>]   | <span class="number">0</span>x0000000000000002 |                    |</span><br><span class="line">  <span class="number">520</span> | current     | <span class="number">0</span>x00007f7f3be87c20 | <span class="number">0</span>x000000000000ed8b |</span><br><span class="line">  <span class="number">296</span> | cp          | <span class="number">0</span>x00007f7f3d3a5100 | <span class="number">0</span>x0000000000440848 |</span><br><span class="line">  <span class="number">304</span> | i           | <span class="number">0</span>x00007f7f3be87c38 | <span class="number">0</span>x000000000044353a |</span><br><span class="line">  <span class="number">312</span> | catches     | <span class="number">0</span>x0000000000000001 |                    |</span><br><span class="line">  <span class="number">224</span> | arity       | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">  <span class="number">232</span> | arg_reg     | <span class="number">0</span>x00007f7f3cbc04f8 | <span class="number">0</span>x000000000000320b |</span><br><span class="line">  <span class="number">240</span> | max_arg_reg | <span class="number">0</span>x0000000000000006 |                    |</span><br><span class="line">  <span class="number">248</span> | def..reg[<span class="number">0</span>] | <span class="number">0</span>x000000000000320b |                    |</span><br><span class="line">  <span class="number">256</span> | def..reg[<span class="number">1</span>] | <span class="number">0</span>x0000000000000c8b |                    |</span><br><span class="line">  <span class="number">264</span> | def..reg[<span class="number">2</span>] | <span class="number">0</span>x00007f7f33ec9589 |                    |</span><br><span class="line">  <span class="number">272</span> | def..reg[<span class="number">3</span>] | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">  <span class="number">280</span> | def..reg[<span class="number">4</span>] | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">  <span class="number">288</span> | def..reg[<span class="number">5</span>] | <span class="number">0</span>x00000000000007d0 |                    |</span><br><span class="line">  <span class="number">136</span> | nsp         | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">  <span class="number">144</span> | nstack      | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">  <span class="number">152</span> | nstend      | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">  <span class="number">160</span> | ncallee     | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">   <span class="number">56</span> | ncsp        | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">   <span class="number">64</span> | narity      | <span class="number">0</span>x0000000000000000 |                    |</span><br><span class="line">---------------------------------------------------------------</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>“dirty” IO threads intended to replace the async thread pool used by the file driver<br>
but dirty IO not used by OTP today<br>
字面常量不会再被copy，但是ets中人会被copy <a href="http://www.erlang-factory.com/euc2017/kenneth-lundin">More</a></p>
</blockquote>
<ul>
<li>新增的调试工具</li>
</ul>
<blockquote>
<p>msacc<br>
新增的参数 +IOt +IOp 可以使用msacc:start/1、msacc:print/0来查看sleep time 如果这个值很低可以增大+IOt</p>
</blockquote>
]]></content>
      <categories>
        <category>Erlang</category>
      </categories>
      <tags>
        <tag>Erlang</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库之分区、分片、分表</title>
    <url>/2021/07/12/database-sharding-partitioning/</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>数据库</category>
        <category>分片 分区 垂直扩展 水平扩展</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>项目往事之团队</title>
    <url>/2021/06/01/project-member/</url>
    <content><![CDATA[<h2 id="组成"><a class="markdownIt-Anchor" href="#组成"></a> 组成</h2>
<ul>
<li>项目总是由形形色色的人构成，不同的专业研发、运营、运维等。重点说说研发，研发包括三个部分：
<ol>
<li>程序（一般分为前端/后端、客户端/服务器）。</li>
<li>策划 (一般分为主策划、剧情、数值、文案，执行等)。</li>
<li>美术 (一般分为3d,2d,原画，场景，模型，动画等)。</li>
</ol>
</li>
</ul>
<h2 id="类型"><a class="markdownIt-Anchor" href="#类型"></a> 类型</h2>
<p>以下只区分程序、策划、美术三大的分类。在所见的团队中大致分为四类：</p>
<ol>
<li>要饭类型<br>
在这类型的团队中，策划是短板。其他成员都在做出盈利产品的所要求的的基准水平线以上。<br>
策划低于或者稍高于基准线，这个就看天吃饭，让用户老爷们赏点饭吃，靠稳定的服务，运营、美术品质等捞取一点利润，基本上就是个苦逼项目组。</li>
<li>体弱多病型<br>
这类型团队中，程序是短板。举个不太恰当的例子，程序的稳定性效率等如同一个人身体的健康，策划的设计理念就是其梦想。梦想很大很好，身体很弱很虚。<br>
发热、耗电、crash，服务器回档、宕机、卡顿等，这种团队基本就是过了今天没有明天，等死型，当然也有遇到神医，也能病去体健，再创辉煌。但是基本上是在有时间有钱的背景下，偶发的特殊情况。</li>
<li>希望型<br>
这种团队中大家能力都在做出盈利产品的所要求的的基准水平线以上，个别特别推出，这种团队基本上属于长期合作，有积累，有默契、有韧劲。离成功只差一个契机，这是大家想去的理想团队。</li>
<li>无名氏<br>
这种团队多见于临时拼凑，成立团队的目的各不相同，人员参差不齐，基本上战五渣，见光死。</li>
</ol>
<span id="more"></span>  
<h2 id="经历"><a class="markdownIt-Anchor" href="#经历"></a> 经历</h2>
<p>第四种团队我在职业生涯经历一次，时长三个月，在我离开之后了解到发生了各种奇葩事情，没几个月解散了。<br>
第三种团队我也经历过一次，做出了手游项目的第一个爆款RPG。<br>
其他基本上都是第一种或者第二种团队，这两种中要饭型的团队更多些。我发现一个共同情况，作为项目总负责人PD，总是希望项目其他研发团队帮助项目的短板方，把短板方的工作尽量往其他团队那边转移，通过这样的方式来弥补项目短板，但。最终结果差强人意，导致大家都成了短板。在这过程中，我开始的做法是强烈要求短板方自己或者通过外部手段（招聘、培训等）来提高，但往往受领头人的思维、解决问题能力，更重要的所能调配的资源限制，无法展开，往往变成别人眼中的“喷子”，慢慢的也就躺平了。<br>
一直在思考的这样的问题，在有限的资源下，怎么才能把事情做成，发挥最大能量？</p>
<h2 id="谬论"><a class="markdownIt-Anchor" href="#谬论"></a> 谬论</h2>
<ol>
<li>放弃没希望的团队。一些团队一边不给资源(时间、人力等)，一边还高举高打，满嘴的愿景，对各种不合理视而不见，凡此种种，及时止损。</li>
<li>部分团队有着明显的短板，但是受制于手中资源，无法做出改变，要仔细斟酌，以我的目的为优先做思考，为自己展开所有行为提供指引。</li>
<li>对多努力还已有希望的团队适用，努力争取资源，试试蚂蚁啃大象的策略，先做出局部改变，并让握有资源的人看到，并逐渐把所有相关人员全部拉入解决问题的圈子里来，让我遇到的问题转化成大家都要面对的问题。</li>
<li>谁的问题，就是谁的问题。对所有不符合产品所有要求的能力基准线以下的人，敦促其主动学习，通过集中培训等方式促进其提高，并对在规定时间仍不达标的人实施转岗、劝退等措施。</li>
<li>招符合团队素质要求的人，宁缺毋滥，如果不能又快又好，优先选择好。当然适可而止。</li>
</ol>
<p><strong>在团队组建的初期就要拿到两样最重要的东西（人事权和钱），最基本的要拿到人事权，选谁用谁得自己说了算。只招复合团队素质的人，宁缺毋滥。</strong></p>
]]></content>
      <categories>
        <category>项目</category>
        <category>团队</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>Erlang 虚拟机内的内存管理</title>
    <url>/2017/12/24/zhengsyao_Erlang%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88Lukas%20Larsson%E6%BC%94%E8%AE%B2%E5%90%AC%E5%86%99%E7%A8%BF%EF%BC%89/</url>
    <content><![CDATA[<h1 id="erlang-虚拟机内的内存管理lukas-larsson演讲听写稿"><a class="markdownIt-Anchor" href="#erlang-虚拟机内的内存管理lukas-larsson演讲听写稿"></a> <a href="https://www.cnblogs.com/zhengsyao/p/erts_allocators_speech_by_lukas_larsson.html">Erlang 虚拟机内的内存管理（Lukas Larsson演讲听写稿）</a></h1>
<p>Erlang核心开发者Lukas Larsson在2014年3月份Erlang Factory上的一个演讲详细介绍了Erlang内存体系的原理以及调优案例：</p>
<p><a href="http://www.erlang-factory.com/conference/show/conference-6/home/#lukas-larsson">http://www.erlang-factory.com/conference/show/conference-6/home/#lukas-larsson</a></p>
<p>在这里可以下载slides和观看视频（为了方便不方便科学上网的同学，我把视频搬运到了 <a href="http://v.youku.com/v_show/id_XNzA1MjA0OTEy.html">http://v.youku.com/v_show/id_XNzA1MjA0OTEy.html</a> ）</p>
<p>这个演讲的内容很丰富，原理介绍很细致，但是slides比较简略，所以我把这个演讲的整个内容听写出来了，收获颇多，完整的transcript如下：</p>
<hr>
<span id="more"></span>
<p>Thank you.</p>
<p>Page 2<br>
When I wrote this talk, I thought that I was going to give a bunch of examples about how you analyse memory and see what the different allocators and things how the Erlang virtual machine works and spend a lot of focus on doing actual examples.<br>
It turned out that the theory of this stuff is quite complicated, so it’s more of theory talk and having some stories at the end rather than being a story focused.<br>
So I am going to talk about the problem and why there are memory allocators in Erlang virtual machine and what they are used for and different handling, going through all the different concepts with the memory allocators, so that you get the terminology right, so that you know the different options you want to set so on and so forth, get to know all the different things we are talking about when talking about blocks, when talking about carriers and so on.<br>
I’m going to have look at the statistics that you can gather. There are a lot of statistics and main reason why we have the allocators implementated the way they are is because we can gather the statistics about your system, try to figure out, ok this is an optimal way of using your memory.<br>
We are going to have look at two different cases where we have been looking at the statistics that we can get from Erlang allocators, making modifications, and hopefully make system work better.<br>
And at the end we’ll look at some of the new features, because there are a lot of development happening in the allocators, we’ve spent a lot time optimizing these things and trying to shrink the fragmentation to become smaller and smaller.</p>
<p>Page 3<br>
The reason why we have memory allocators in Erlang virtual machine is because the normal malloc and so on are relatively slow for very small allocations, so when you are allocating small ets objects some where, it quite heavy operation to have to do syscall go all the way down, so we kind of cache memory up in the virtual machine.<br>
Also, in order to battle fragmentation, we use different strategies for how to allocate data, allocating something like a module or something like that, ok, you want to spend a lot of time finding the correct place to allocate that memory, but allocating something like a message being sent to another process, you don’t want to spend as many cpu cycles to try to find the perfect place in memory, because it will be deallocated when you receive the message. So we have different strategies depending what type of memory that we are allocating.</p>
<p>Also there is no way to get statistics in a cross-platform manner. Now we want to have out of the allocators if you want to just use malloc or something like that.</p>
<p>If you want to try on your system running without erlang allocators, just use malloc from the beginning, you pass that flag to Erlang virtual machine, and it will disable everything. And you just run normal malloc.<br>
Sometimes, this is faster, I was looking at a benchmark that’s called ESTONE, I was going to see, ok, how much faster are these allocators, I switched them off, and benchmark went faster than using the allocators.<br>
So it’s not always, but that’s what you get for some statistics benchmarks.<br>
In real production environments, they help a lot. There is another benchmark I have been running to do a 4G telephone benchmark thing, and there there is a 40% speedup to see in these allocators than using malloc and so on.<br>
So in real world applications, it’s usually better for small benchmarks, they overact sometimes, bits over…<br>
The allocators also help a lot when you are doing NUMA, so lots of cores lots of things…</p>
<p>Page 4<br>
So I’m going on talk a bit about concepts.<br>
These are the forming things that we are talking about.<br>
carriers and blocks, single- vs. multi-block carriers, how do multiblock work and what’s thread specific allocators.</p>
<p>Page 5<br>
So talking about blocks.<br>
This is a terminology so that we can talk about these things.<br>
A block is one continuous piece of memory that Erlang virtual machine needs, this is something like for instance when you do a ets insert, that piece of data becomes a block, heap and stack of a Erlang process is a block, and message being sent from one process to another is copying inside a block, so it’s continuous piece of C memory.<br>
We have carriers.<br>
Carriers is something container, contains one or more blocks. So we have something looking like that.<br>
So we have a header, saying ok that this is a carrier of this type with these settings and so on. And we put the block into it.<br>
And as we continue with more operations on ETS table, we put more and more data, hopefully in a good place into the block. And we delete something, and we get fragmentation. We might end up with something looking like this.<br>
Now these blocks are like this. They are normally … we align them, normally aligned at 18 bit limits, so they are about 256 KB minimum, aligned at that limit, so it allows us to do lots of optimizations.</p>
<p>The size of how much memory can be allocated can be controlled with many different settings.</p>
<p>Page 6<br>
Before I do that, we talk about single and multiblock carriers.</p>
<p>So when looking at the statistics on the allocators, we have two different concepts there, so we have single block carrier which is something that contains one block, it’s carrier that contains one block of memory.</p>
<p>Now normally you want to put large, for some definition of large block into one single block carrier.<br>
And if you have small blocks, you want to put them into the same carrier, this is because the operating system is quite good at handling large continuous chunks of memory, and single block carrier usually uses just allocator like malloc normally.</p>
<p>Large depends on your context, sometimes, large can be something like 256 bytes, sometimes it can be 5 MB, so it depends a bit on your context.</p>
<p>The default is half MB, which seems to work for most situations. So if you have a block of some sort that’s smaller than 512 KB, then it’s placed on multiblock carrier, if it’s bigger, then it’s placed on single block carrier.</p>
<p>And you control that by single block carrier threshold.</p>
<p>Normally you want to have most of your data in multiblock carriers.<br>
So in a normal system that you are running you have most … I don’t know … 80<sub>85</sub>90% of your data to be part of multiblock carrier.</p>
<p>So if you realize in a system that you are running that you have a lot of singleblock carriers, not a lot of multiblock carriers, you might want to raise the limit to see, ok , so I know from my code that I’m reading 1 MB messages from TCP socket all the time, this becomes 1 MB binaries, and that’s bigger than 512 KB, those are always put into singleblock carriers, so I might want to just adjust the threshold to 1.5 MB, and then , they put all those blocks into multiblock carriers, and hopefully your system will be a lot faster.</p>
<p>When manipulating the threshold you probably also want to change the size of carriers that are being allocated. So if you are increasing the size of individual blocks, you will wanting increase the actual carriers that are being created. So if you increase the threshold to 1 MB, the… I believe the default size of multiblock carriers is 2 MB, the smallest one, and it grows up into 8 MB, depending on how many carriers you have.</p>
<p>Since you doubled the initial amount, you might want to double the next one as well, so you started at 4 MB might grow up to 16 MB, or something of that effect.</p>
<p>Page 7<br>
There are quite a few different types of allocators. These are different areas that you can configure individually how they work.</p>
<p>So we have the heap allocator, the binary allocator, the driver allocator and the ets allocator. So these are the things that you can reason about as an Erlang programmer.</p>
<p>These allocators are normally the ones that you tune. I’ve not seen problems with any allocators yet. Normally somebody allocating binaries that are going out of hand or they have many many small ets stuff that are put into table, they get fragmentation usually because of that. That’s the two normal ones that you have problems with.</p>
<p>There are also temporary, short lived, standard lived, long lived and fix size allocations, and these are emulator internal things.</p>
<p>Page 8<br>
The difference between these emulator internal things:<br>
temporary is a very short time, for something that just lives in a C function, some examples for what can be there.<br>
standard is links, monitors, these kinds of C structures.<br>
short is something that lives across … I don’t know … a scheduler for erlang functions, lives for only 4 or 5 milliseconds, something like that.<br>
long is for things like code, atoms, things that we know could possibly live forever.<br>
fixed are things we know are certain sizes, we can make optimizations because of this, so process control blocks, port control blocks and lots of other things.<br>
If you want to find the exact things that there are, there is a file called erl_alloc.types in the erlang/otp repository under erts, all the mappings are set there and mappings are different if you are running a half-word emulator, if you are running a 64 bit, 32 bit, if you are running windows, unix or …<br>
So many things are depending on operating system that you build the erlang virtual machine for, you have different setting for these things.</p>
<p>Page 9<br>
So talking a bit about…<br>
So, single blocks carriers are quite easy, you don’t have to manage them, you have one block one carrier, and that’s it, and one carrier is one chunk of memory requested from operating system. so it’s very easy to handle.</p>
<p>multiblocks, on the other hand, are quite difficult. you have a lots of small areas because you need to keep track of where I can put this piece of memory. I need to place something that’s 8 bytes big, and I need to look for the best place to put it, and spend a good amount of time for it.<br>
So we have a few ~7 different strategies that you can use in order to allocate where to put the blocks inside multiblock carrier.<br>
So we have the block oriented ones, these are strategies that span carriers, so if you have two carriers, and with them build the trees with all the free blocks of all the carriers that are in that allocator at the point.<br>
We have the best fit, it’s just, it’s the best fit looks for the one with the least wastes, so if you have a block that’s 8 bytes, and you find the slot that’s 9, and next smaller slot is 7, then you put it in the 9 slot, and so on.<br>
Address order best fit works in the same way, only that if there is a tie, it uses the one with the lowest address, rather than just taking the one that was put in the queue last.<br>
Address order first fit tries to take the one with the lowest address that you can fit them.<br>
Good fit takes the good fit to do it. You can tune with the settings that you define as a good fit. so if you say that it’s ok to waste 10% of the blocks, if I have something that’s 10 bytes big, then a good fit is something that doesn’t waste more than 15 bytes. So something like that, you can tune what you want to have a good fit to be.<br>
A fit, is mostly used for these temporary allocations that are really fast, so just finding something.</p>
<p>We have the carrier oriented ones. these are broken down so that first you have the strategies to say how the carriers are organized, than you have strategies saying how the blocks within a carrier organized.<br>
I think I will get into more details about the…</p>
<p>Page 10<br>
I have a picture here. saying a small example about how best fit works. So we have two carriers, the shaded areas are memories that are taken, the blue and red ones are free slots, so free memory areas.<br>
we build a tree looking something like this, after different carriers saying ok we do a binary search trees, so that is, I thinks it’s a red-black balanced binary search tree, that you look for blocks in.<br>
In the end it looks something like this, the smallest red one all the way to the right, and then you have built up this tree of them, and the neat thing is that this requires of course no memory to build this tree because we save the pointers of this tree in the free slots. So it doesn’t actually take any memory to build this tree. and then we just search this tree to see, ok, which one can be find, and we take a slot, then you take out of the tree, we balance, and then hopefully you find good slot to be in.</p>
<p>So I’ve been talking a lot about the blocks in there, so you have different blocks. but the carriers, where do they come from?</p>
<p>Page 12<br>
So we have two different ways of allocating carriers in the runtime system.<br>
We have something called mseg alloc and the sys alloc.<br>
so the mseg allocator basically tries to shut out the operating system as much as possible, and just allocates big segments. And this is normally used for multiblock carrier allocation.<br>
On linux it uses /dev/zero and opens that as a file, and mmap with different arguments in order to get large chunks of memory.<br>
One of the key things about the mseg alloc is that it has a cache. so it has a cache of certain size of carrier that was just returned to it. I think the default is 10 or something like that, and only normal system, most I see, we have a cache hit rate of about 80%~85%, normally when we are using a lot of carriers in a system.</p>
<p>sys alloc just call to malloc, free or posix_memalign depending on your operating system. It allocates pieces of memory in multiples of a variable you can set there, let’s call them Muxxxx. So I think the default is 2 MB. so it allocates 2 MB no matter if you want to have something that’s let’s say 1 MB. it over allocates 2 MB in order to make it easier for operating system to get less fragmentation of things.<br>
We had a lot of problems with projects that have had fragmentation of virtual memory space, so this is why we help malloc in order to have these nice chunks that it can manage and gets it perfect.<br>
sys alloc is also used to allocate what we call the main carrier. main carrier is an initial carrier, so the first one that’s always there during startup.<br>
The idea with the main carrier is that you have sufficient memory in order to do the normal bootup of erlang emulator without doing any extra allocations in order to speed up starting something.</p>
<p>Page 13<br>
So another picture. Now we are getting into different schedulers.<br>
so we have short live allocator, eheap, binary and all of the different things, they request carriers from mseg alloc.<br>
All of these, we have one chain of these per scheduler in the system. so all of these are locals, you have one ets alloc for scheduler 1, one ets alloc for scheduler 2, etc… So they are all local, and can take advantage of the NUMA architecture of your system, so allocation is always close to you.<br>
And, these small mailboxes, they are say that, of course we have to pass memory around between the schedulers, so if we want to do free or something that we passed over we have to send a message to that scheduler in order to do free, because we don’t have any locks at all on the actual allocators, because we want these to be lock free, so we are doing them via a message passing between the schedulers that do the allocations.<br>
In R16B02, we added a carrier pool that’s shared between different schedulers, you get access to this if you use the carrier oriented algorithms that I was talking about before. and so if you use something like the address order best fit carrier or first fit block something like that, you get to access this pool. This pool get populated of carriers that are below a certain percentage of utilizations, so if you have a carrier on scheduler n, that has utilization of say 20%, so it has quite high fragmentation, then that scheduler can give that carrier to the pool, and somebody that needs a carrier, say scheduler 1 needs a new carrier to allocate data in, it can take that from the pool rather than having that from somewhere else.<br>
You lose some of the NUMA things of course, but you get better memory utilization, which is nice.</p>
<p>For all of the async threads, and all of the driver threads, there is a global allocator that has a big lock in front of it, and all of the data get put into there, so if for instance you are reading a file with binaries, those binaries get put into this global allocator.</p>
<p>And all of these mseg , as if they run out of layers here, we have something called erts_mmap at the bottom as well, that was added in R16B03, that’s something fun as well. If you want to know the details, just ask me afterwards.</p>
<p>Page 14<br>
So, that’s general theoretical background for these things. So getting statistics trying to figure out what’s wrong, let’s dig down to some of these things.<br>
We have different types of allocators, they are called things like these when we are talking about statistics part of them.<br>
So if you do erlang:system_info(allocator), you get information about which allocators are active on your system. It’s not always the same, and it’s definitely not always the same over releases. But doing this, you can get the information about what feed are just enabled on your system. You get all of different settings that you set on you system, you can figure out what your threshold is, or what’s your multiblock carrier strategies and other things like that. And the features like if you have the posix_memalign in your system, if you can lock physical memory in place rather than trying to get linux way of doing memory management. In there, lots of other things.</p>
<p>Page 15<br>
Now you can dig into more detail, even more.<br>
So if you say erlang:system_info, and put one of the type we have seen in the previous slide: eheap_alloc, ets_alloc, something like that, you get list of tuples with lots lots of data.<br>
You can see that, the first structure we have is instances.<br>
Instance 0 is the global allocator that’s used for async threads.<br>
Instance 1 is for scheduler 1, instance 2 is for scheduler 2, etc. etc. etc…<br>
For each instance, we have the version of allocator use, the options set, statistics about the multiblock carriers, statistics about the singleblock carriers, and statistics about the calls made about the carrier.<br>
I’ll break these down for you…</p>
<p>Page 16<br>
So this is what you get out of the data.</p>
<p>Page 17<br>
I put it in a table for you, so you don’t have to read the data stuff.<br>
So, what we get is that we get the current value, we get the maximum value of that parts since the last call to get the statistics, and we get the maximum value of the system life time.<br>
We can see the number of blocks, there we have 1 million, 1 million and 1.8 million blocks.<br>
And there, we get the total size of all of the blocks, I think I actually have a … So we have a 820 MB, 820 MB there, we have maximum, when we have a peak of 3.3 GB of memory.<br>
We can see the carriers, we fit these 1 million blocks into 455 carriers.<br>
We can see the carriers sizes down there as well.</p>
<p>Page 19<br>
Singleblock carrier would of course have the same amount of blocks as carriers.<br>
We can see that the block size is 6, 6, 20, but since we over allocate a bit, the carrier size is 7.5, 7.5 and 25. Quite simple.</p>
<p>Page 20<br>
The number of calls that you can see. We can see that we have done quite a few calls.</p>
<p>Page 21<br>
Quite many, so 28 thousand mega calls has been done to the binary alloc.<br>
So quite a few binaries have been allocated there.<br>
We freed roughly the same amount which is a good thing, otherwise we would have memory leak.<br>
And we have been able to reallocate some as well.<br>
And we can see that mseg alloc has done 24 thousand of allocations, while sys alloc has done zero. so this is a good thing.<br>
So that’s for the singleblock and multiblock things.</p>
<p>Page 22<br>
So you can also get the statistics about the carrier allocators.<br>
We can get the amount of segments, cache information, seeing the alloc, dealloc and destroy.<br>
So here we can see the cache working.<br>
We have mseg alloc of 464 there, while actually we only created 40 carriers.<br>
So we have a quite high cache hit rate there. We have done 464 calls, only 40 of them ended up in OS call.</p>
<p>I am justing think of how much time I have… which seems to be plenty… that’s good…</p>
<p>Page 23<br>
So some case study to see how you analyze these things, and get these data once you understand what they mean.<br>
So I run across two cases. I run across many cases, but these ones are quite useful for the open source community, because you guys seem to run into them a lot more than our commercial customers.</p>
<p>Page 24<br>
So the first one I want to talk about is large binaries.<br>
So there was this person that realized that I am running strace, and I know that these allocators are supposed to be really efficient, it should be using mmap to allocate my stuff, but for some reason, it’s not using mmap, it’s using malloc instead. It’s using a lot malloc.</p>
<p>Page 25<br>
So I requested the statistics of binary allocators.<br>
In there, you can see that there were about 300 mega calls being done to binary alloc.<br>
And we have 0.4 mega calls done to mseg alloc.<br>
So we have a discrepancy because we want to have most of our stuff into the mseg allocator not to the system allocator, because mseg allocator means that we use multiblock carriers, while system allocator means that we are using singleblock carrier mostly.<br>
And we could see that we have sys alloc call of 1.4 mega calls, so quite a discrepancy there.<br>
So this is when bells are whispering for me, saying something is wrong with these settings.<br>
So at this point you can reason about the allocators, something is wrong with how the thresholds set for which things are being put. I noticed this is binary alloc or so, so this person is allocating large binaries than the actual singleblock threshold for most of the binaries, and therefore they push into singleblock carriers, and which is not as efficient.<br>
Going back, we can see that multiblock carrier size is about 2.4 GB, and the singleblock carrier size is 11 GB of memory.<br>
So it’s a big discrepancy, normally we want to have the reverse if not even more in favor of multiblock carriers in there.</p>
<p>So, what can we do about this?<br>
So we want to adjust the singleblock carrier threshold somehow, but how should we adjust it?</p>
<p>So looking at the statistics, we can also get the average block size that’s in the single block carriers.<br>
You take the number of blocks divided by the total size of the carriers, we can see that the block size is about 1.68 MB, in this case it was reading from TCP socket.<br>
Now we have the block size, ok, this is the average block size. So we probably want to go a bit over that size when tuning the allocators.<br>
And in the end we ended up setting it to 2MB, which is reasonable limit above there, and is a nice clean number.<br>
So, that put the binaries that are greater than 2 MB into singleblock carriers, while puts that are smaller than 2 MB into multiblock carriers.<br>
And since multiblock carriers are being done by mmap, and you get the caching of mseg and all that, the performance increase is quite good I believe.<br>
And also of course, increase the largest multiblock carrier size and the smallest multiblock carrier size, as these two last ones say, for only the binary allocator, this is where the strength of the erlang runtime allcoators come in, because you can say that, I only was setting the binary allocators, because if you set the settings for all of the allocators, then you will have the problem, most probably with ETS or something like that, over allocates the memory than you really want in your system.<br>
So you can specify saying I have problem only with binary allocations, therefore I put only binary tuning into my emulator.</p>
<p>Page 27<br>
So second case that I was running into … was actually helping Fred Hebert with a problematic allocator, which he wrote a big blog post about it, so this is data if you read the blog post.<br>
The symptom that he was having was that erlang:memory(total) was showing about 7 GB of used memory, but top in his operating system was showing that 15 GB memory was being used by the BEAM.<br>
And then all of the sudden, he got some kind of small traffic spike, and he got crashed on ets alloc failing to allocate. And he was confused, because Hey I have … it says I have 7 GB only, and then it was 15 GB, I don’t have memory to allocate these things.<br>
Now the thing to know about erlang:memory(total) is that is the total areas of the blocks in your system.<br>
It’s not the total areas of the carriers in your system.<br>
So there is the discrepancy, it’s only the used areas that is the Erlang total, it’s not the actual allocated from the operating system.<br>
So if you see this discrepancy between what erlang:memory gives and what the top in your operating system gives, most probably you have some kind of fragmentation problem with your allocators.</p>
<p>Page 28<br>
So again, looking at the statistics in there, we can see that he has a lot of blocks, and he has a blocks size that was at the moment 1.6 GB, I believe this was just one instance, so it’s only one scheduler.<br>
But we can see the max block size is 6.8 GB, but we can see at the carrier size, was largely the same for the current and maximum, so this is what our problem is, you have a fragmentation in the allocation of these binaries.<br>
So for some reason, the allocators were allocating binaries in lots of different carriers, but one day when releasing them, it was not releasing all of the binaries within a carrier, it was one binary there, one binary there, and it was impossible to release these carriers. And then, he got a spike in ETS inserts, and he cannot put ets data into a carrier puts for binary allocation. And therefore trying to create ETS carriers, and you run out of memory.<br>
So again we have to know what the average block size is, we can see that block size is about 800 bytes per block when we were at current, they had peak of 1.7 KB per block, and the carriers were about 7.8 and 7.7 MB per carrier. This is something you would expect.<br>
But if you take the block size divided by the carrier size, we have a utilization about 22% when running at current, which is not good at all. But when we are at max, we had 93%, which is quite ok.<br>
So what we want to do here is to find a better strategy for allocate these binaries so that we don’t get into scenario when we are freeing binaries, the carriers can not be returned to operating system.</p>
<p>Page 29<br>
So what we ended up changing there was to use … the default allocator for binary is a normal best fit allocator, by using the address order best fit, we are trying to squeeze allocations further down into the memory space and therefore compacting them. Spending a couple of CPU cycles doing this, …(没听清), notice any difference.<br>
We also shrunk the size of the largest multiblock carriers, by doing this we were hoping that statistics would be in our favor, so that we could free more of the carriers. And that turned out to be the case as well.<br>
I don’t know exactly what his xxx(没听清，应该指的是内存使用率) now is, but it’s not at 20%, that’s more like 50% or 40%, which saved the system in a lot of cases. So there’s nothing to deal with these crashes any more.</p>
<p>Page 30<br>
Some of the new features are coming up lately.<br>
So I was talking about the pool that was coming in R16B01, so this can only be migrated from things with the same type. It’s migration in between schedulers, but it’s still binary to binary migration, so you cannot migrate something from a binary allocation to an ets allocation yet. This is something that we probably get to work on eventually.<br>
So this will not save the fragmentation problem having this pool, but it helps when you are having a scenario where you are allocating in a lot of schedulers in high load, and then your load shrinks for once, and it helps a lot, and you get a lot of deallocations. The reason for this introduction is that we have a customer that was in memory goaf as the load of system decreased, which is not really what you want to see, because you had a peak and then we allocate a lot of memory, lots of memory, and then the load shrunk, and he was just allocating in one scheduler, but he was not able to use the carriers in the other schedulers, and therefore the memory of that scheduler increased, and it wasn’t able to deallocate the other schedulers. So by migrating these carriers to scheduler 1, we solve that problem. This by the way is turned on by default in 17.0, so check your system and see if you want to have it or not, we have only see the positive effective of this, but it might be possible that there are some down sides for it.<br>
In R16B03, we have something called super carrier, which is where the erts_mmap functionality was add in. So this is a way for us to prealloc a huge chunk of memory for Erlang virtual machine at startup, so that we don’t have to request for memory from operating system.<br>
The reason why we put this in, is because we have a virtualized environment where one of our customers is running, we took about 20 seconds to do a malloc. So it was taking a long time, and there was a test was timing out for some reason. So we put this in place, so that they could preallocate 8 GB of memory, and don’t have to request it from memory system at such long intervals.<br>
It can also be used to limit the amount of memory that Erlang virtual machine uses, but ulimit is a better tool for that than using this.</p>
<p>(Question: Why is that? Why is ulimit better…?)<br>
Answer: You get the same results. And I think operating system in general is better at managing these things, because you kind of … the reason why we use do singleblock carriers as operating system allocations is because it can cheat by taking memory from caches and so on and so on, if we are allocating things with mmap we don’t get the caches that malloc uses and so on, so we don’t get access to all of the memory that’s in the system. So but if you use ulimit, you don’t get the downside, but you get the same benefits.</p>
<p>Q&amp;A</p>
<ol>
<li>
<p>Question: there is one super carrier for the entire system. So how does that work with the NUMA architecture?<br>
Answer: I don’t think we’ve done any benchmark on that actually to see how that works. The implementation about how it takes carriers and so on, I might be a bit fuzzy about it, so I am not 100% sure, but it some kind of taking on the same side on the allocating things. Don’t know, unfortunately it’s the answer.</p>
</li>
<li>
<p>Question: how does the migration of carrier work with the NUMA system?<br>
Answer: Yes, you can have problem with that, definitely. You will have remote memory access as you might want them to be. But if you do not want this behaviour, it’s very easy to shut off. you dont have to deal with that. In systems that do not have lot of NUMA interactions with different things, it’s just benificial to do it. Normally you dont want to have this scenario any way where memory is being allocated not release from these other parts in there.</p>
</li>
</ol>
<p>(You have that problem with process migration in scheduler)<br>
Yeah, as long as you do message passing, or interacting environments, …, we don’t group things in NUMA nodes for processes in order for them to not have the overhead, and if you send a message from one process to something in another NUMA node, the memory of that message will remain in the original NUMA node, so we have a lot of these things, any way. …</p>
<ol start="3">
<li>
<p>Question: what does the S+1 mean? (指的是slides第15页中的最后一行)<br>
Answer: I guess the S+1 I was talking about is just … one plus… that’s the two one.<br>
The thread zero … and then 1 is the first scheduler, 2 is the second scheduler, 3 is the third scheduler, and so on and so on… I might have made a mistake in this slide SO I’ll fix it.<br>
No, there is nothing at the end over there, it just ends at the last scheduler.</p>
</li>
<li>
<p>Question: If NIF uses the driver allocator?<br>
Answer: NO, it uses heap allocator, you allocate directly on the heap for things when you are building stuff there. of course if you make binaries that’s bigger than 64 bytes, you will end up in the binary allocator. but NIFs have the advantage of building stuff directly on the heap, which is why they are a bit faster when calling small stuff than drivers.</p>
</li>
</ol>
<p>Unless of course you go over the heap size, then it will create heap fragment, which is part of the heap allocators but in the different memory area.<br>
All of the fragments get collapsed when you do garbage collection.</p>
<p>5 Question: where can I find the information about this stuff without reading the source code.<br>
Answer: Yes you can. you can read my mind, and there are two other minds you can read as well(笑). In part of doing the work done with Fred to get the fragmentation problem, I was working … recon(听不清，就是一起开发了recon). And see modular in recon_alloc, does some basic analysis for you, trys to figure out what’s in the system. it has maybe 7 or 8 functions, their data analyse different aspects of things, problems that we have encountered. We are trying to add more things to it, but what I find is that most of the problems that you encounter are unique. It’s not like that it’s a general problem for everybody because then it would be a general setting, but if it’s almost always a specific problem that somebody’s having because they’ve written their code in certain way and therefore this happens. BUt for this fragmentation part, finding out there are many singleblock carriers rather than multiblock carriers, their functions in this library can do that.<br>
With lot of documentation explaining all of these stuff, the documentation is almost better than the tool. I would say. So just reading documentation explains most of the things I did in my slides.</p>
<p>听写水平有限，仅供参考。</p>
]]></content>
      <categories>
        <category>Erlang</category>
      </categories>
      <tags>
        <tag>Erlang</tag>
      </tags>
  </entry>
</search>
